[
["intro.html", "2 Введение 2.1 Наука о данных 2.2 Не R единым 2.3 Основные этапы исследования 2.4 Введение в RStudio 2.5 R как калькулятор 2.6 Комментарии 2.7 Функции 2.8 Переменные 2.9 Вектор", " 2 Введение 2.1 Наука о данных Наука о данных — это новая область знаний, которая активно развивается в последнее время. Она находиться на пересечении компьютерных наук, статистики и математики, и трудно сказать, действительно ли это наука. При этом это движение развивается в самых разных научных направлениях, иногда даже оформляясь в отдельную отрасль: биоинформатика вычислительная криминалистика цифровые гуманитарные исследования датажурналистика … Все больше книг “Data Science for …”: psychologists (Hansjörg 2019) immunologists (Thomas and Pallett 2019) business (Provost and Fawcett 2013) public policy (Brooks and Cooper 2013) fraud detection (Baesens, Van Vlasselaer, and Verbeke 2015) … Среди умений датасаентистов можно перечислить следующие: сбор и обработка данных трансформация данных визуализация данных статистическое моделирование данных представление полученных результатов организация всей работы воспроизводимым способом 2.2 Не R единым R (R Core Team 2019) — это один из популярных языков для анализа данных. Однако у него вполне есть и альтернативы: Python (VanderPlas 2016; Grus 2019) Julia (Bezanson et al. 2017) bash (Janssens 2014) java (Brzustowicz 2017) … Кроме того ответы на любые проблемы можно найти в… R for data science (Wickham 2016), онлайн R community stackoverflow рускоязычный телеграм-канал (но там есть правила по задаванию вопросов) телеграм-канал, где собираются все новости по R любой поисковик … 2.3 Основные этапы исследования формулировка гипотез(ы) выбор зависимой и независимых переменных сбор данных работа с данными, которую можно представить следующей схемой: При анализе данных бывают разные соблазны, с которыми нужно бороться: Cherry Picking — выбор только тех данных, которые удовлетворяют гипотезе. Data Dredging — проведение множества тестов, пока не появится статистически значимый результат. Систематическая ошибка выжившего — анализ только одной группы объектов (выжившим), так как данных по другой группе (погибшим) данных нет. Ложная корреляция — наличие высокой корреляции между переменными не гарантирует, что между ними есть причино-следственная связь. Неуравновешанная выборка — если выборка неуравновешена, она перестает представлять генеральную совокупность, что может исказить выводы. Чтобы проиллюстрировать этапы исследования давайте возьмем данные из опрос, который вы сейчас пройдете. 2.4 Введение в RStudio R — это язык программироваия. RStudio — наиболее популярный IDE (Integrated Development Environment) для R. Когда вы откроете RStudio первый раз, то увидеть что-то такое: Если нажать наверху на кнопку , то можно будет увидеть все четыре окна: 2.5 R как калькулятор 2+9 ## [1] 11 50*(9-20) ## [1] -550 3^3 ## [1] 27 9^0.5 ## [1] 3 9+0.5 ## [1] 9.5 9+.5 ## [1] 9.5 pi ## [1] 3.141593 Остаток от деления: 10 %% 3 ## [1] 1 Теперь вы готовы решит ваше первое выражение (результат округлите до 3 знаков после запятой): \\[\\frac{\\pi+2}{2^{3-\\pi}}\\] 2.6 Комментарии Любой текст после знака # на той же строчке не исполняется 2+2 # это четыре ## [1] 4 # можно сюда написать комментарий 3+3 ## [1] 6 2.7 Функции Самая важная часть R — функции. Вот некоторые из них: sqrt(4) ## [1] 2 abs(-5) ## [1] 5 sin(pi/2) ## [1] 1 cos(pi) ## [1] -1 sum(2, 3, 9) ## [1] 14 prod(5, 3, 9) ## [1] 135 sin(cos(pi)) ## [1] -0.841471 У каждой функции есть имя и аргументы (от нуля и вверх). Все аргументы перечисляются в круглых скобках, и разделены запятой: round(pi, 2) ## [1] 3.14 Каждый аргумент функции имеет имя и порядковый номер. Если вы используете аргументы функции, вы можете помещать их в любом порядке. Если имена аргументов функции не названы, то их следует перечислять в соответствии с порядковым номером. round(x = pi, digits = 2) ## [1] 3.14 round(digits = 2, x = pi) ## [1] 3.14 round(x = pi, d = 2) ## [1] 3.14 round(d = 2, x = pi) ## [1] 3.14 round(pi, 2) ## [1] 3.14 round(2, pi) # это не то же самое, что на предыдущих строчках! ## [1] 2 Существуют функции без аргументов, но с ними все равно нужно использовать скобки: Sys.Date() # correct ## [1] &quot;2020-09-04&quot; Sys.Date # wrong ## function () ## as.Date(as.POSIXlt(Sys.time())) ## &lt;bytecode: 0x5eab0d8a2128&gt; ## &lt;environment: namespace:base&gt; Все функции в R имеют документацию. Ее можно увидеть, если поставить вопросительный знак перед именем функции: ?Sys.Date Исследуйте следующую функцию log() и посчитайте следующий логарифм: \\[\\log_3(3486784401)\\] 2.8 Переменные Все в R можно хранить в переменной: x &lt;- 5 + 6 В результате работы предыдущей команды, нет никокого результата в консоли, однако новая переменная x окне окружения. Теперь можно использовать эту новую переменную: x + x ## [1] 22 sum(x, x, 7) ## [1] 29 Все эти операции не изменяют значения переменной x. Чтобы изменить значения, нужно сделать новое приписывание: x &lt;- 5 + 6 + 7 Существуют горячие клавиши для создания &lt;- в RStudio: Alt -. Для приписывания значения можно использовать и знак =, однако рекомендуется все же использовать &lt;- для приписывания и знак = для перечисления аргументов функции. Чтобы удалить переменную можно использовать функцию rm(): rm(x) x ## Error in eval(expr, envir, enclos): object &#39;x&#39; not found Переменные бывают разного типа, вот основные: typeof(4.3) # числа ## [1] &quot;double&quot; typeof(&quot;тро-ло-ло&quot;) # строки ## [1] &quot;character&quot; typeof(TRUE) # логические ## [1] &quot;logical&quot; 2.8.1 Сравнение переменных Переменные можно сравнивать: x &lt;- 18 x &gt; 18 ## [1] FALSE x &gt;= 18 ## [1] TRUE x &lt; 100 ## [1] TRUE x &lt;= 18 ## [1] TRUE x == 18 ## [1] TRUE x != 18 ## [1] FALSE Оператор ! изменяет логические значения на противоположные: !TRUE ## [1] FALSE !FALSE ## [1] TRUE !(x &gt; 18) ## [1] TRUE Стоит помнить о логических операциях, которые позволяют соединять разные логические выражения: x &lt;- 5 x &gt; 2 &amp; x &lt; 2 # логическое и ## [1] FALSE x &gt; 10 &amp; x &lt; 100 # логическое и ## [1] FALSE x &gt; 2 | x &lt; 4 # логическое или ## [1] TRUE x &gt; 6 | x &lt; 4 # логическое или ## [1] FALSE 2.9 Вектор Объект в R, который содержит элементы одного типа, называется вектор. Вектор можно создать при помощи функции c(): c(3, 0, pi, 23.4, -53) ## [1] 3.000000 0.000000 3.141593 23.400000 -53.000000 c(&quot;Нижний Новгород&quot;, &quot;Пермь&quot;, &quot;Санкт Петербург&quot;) ## [1] &quot;Нижний Новгород&quot; &quot;Пермь&quot; &quot;Санкт Петербург&quot; c(FALSE, FALSE, TRUE) ## [1] FALSE FALSE TRUE a &lt;- c(2, 3, 4) b &lt;- c(5, 6, 7) c(a, b) ## [1] 2 3 4 5 6 7 Для последовательностей чисел есть и другой способ: 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 3:-5 ## [1] 3 2 1 0 -1 -2 -3 -4 -5 Теперь становится понятно, что все, что мы видели раньше было вектором длины один. Вот почему там все время было [1]: Это индекс элементов в R. Посмотрите: 1:60 ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ## [26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 ## [51] 51 52 53 54 55 56 57 58 59 60 60:1 ## [1] 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 ## [26] 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 ## [51] 10 9 8 7 6 5 4 3 2 1 На этом месте также должно стать очевидно, что в отличие от кучи языков программирования R считает с 1, а не с 0. Для того чтобы создавать арифметические прогресии существует функция seq(): 1:20 ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 seq(from = 1, to = 20, by = 1) ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 seq(from = 2, to = 100, by = 13) ## [1] 2 15 28 41 54 67 80 93 Используйте аргумент length.out функции seq(), чтобы создать арифметическую прогрессию от \\(\\pi\\) до \\(2\\pi\\) длины 50. Кроме того в R есть какое-то количество встроенных векторов: letters ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; ## [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; LETTERS ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; ## [20] &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; month.name ## [1] &quot;January&quot; &quot;February&quot; &quot;March&quot; &quot;April&quot; &quot;May&quot; &quot;June&quot; ## [7] &quot;July&quot; &quot;August&quot; &quot;September&quot; &quot;October&quot; &quot;November&quot; &quot;December&quot; month.abb ## [1] &quot;Jan&quot; &quot;Feb&quot; &quot;Mar&quot; &quot;Apr&quot; &quot;May&quot; &quot;Jun&quot; &quot;Jul&quot; &quot;Aug&quot; &quot;Sep&quot; &quot;Oct&quot; &quot;Nov&quot; &quot;Dec&quot; 2.9.1 Приведение типов По определению вектор может содержать только единицы одного типа. Но что происходит, если соединить элементы разных типов? c(1, &quot;34&quot;) ## [1] &quot;1&quot; &quot;34&quot; c(1, TRUE) ## [1] 1 1 c(TRUE, &quot;34&quot;) ## [1] &quot;TRUE&quot; &quot;34&quot; Мы видим иерархию: строки &gt; числа &gt; логические выражения. Это не универсально между разными языками программирования. Также это не зависит от количество элементов того или иного типа: c(1, 2, 3, &quot;34&quot;) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;34&quot; c(1, TRUE, FALSE, FALSE) ## [1] 1 1 0 0 Приведение типов может случится, во время выполнения и других операций: 5+TRUE ## [1] 6 2.9.2 Операции с векторами и векторизованные операции Все операции, которые мы раньше обсуждали, можно сделать с векторами одинаковой длины: 1:5 + 6:10 ## [1] 7 9 11 13 15 1:5 - 6:10 ## [1] -5 -5 -5 -5 -5 1:5 * 6:10 ## [1] 6 14 24 36 50 Если один из векторов имеет длинну один, то получится так называемая векторизованная операция — операция произойдет с каждым элементом вектора: 1:5 + 7 ## [1] 8 9 10 11 12 1:5 - 7 ## [1] -6 -5 -4 -3 -2 1:5 / 7 ## [1] 0.1428571 0.2857143 0.4285714 0.5714286 0.7142857 В R очень много векторизованных функций: sin(1:5) ## [1] 0.8414710 0.9092974 0.1411200 -0.7568025 -0.9589243 sqrt(1:5) ## [1] 1.000000 1.414214 1.732051 2.000000 2.236068 abs(-5:3) ## [1] 5 4 3 2 1 0 1 2 3 2.9.3 Индексирование вектора Как получить какое-то значение или несколько значений из вектора? Нужно использовать индекс: x &lt;- c(3, 0, pi, 23.4, -53) y &lt;- c(&quot;Нижний Новгород&quot;, &quot;Пермь&quot;, &quot;Санкт Петербург&quot;) x[4] ## [1] 23.4 y[2] ## [1] &quot;Пермь&quot; Вектор можно использовать в качестве индекса: x[1:2] ## [1] 3 0 y[c(1, 3)] ## [1] &quot;Нижний Новгород&quot; &quot;Санкт Петербург&quot; Отрицательный индекс исключает элементы из вектора: y[-2] ## [1] &quot;Нижний Новгород&quot; &quot;Санкт Петербург&quot; x[-c(1, 4)] ## [1] 0.000000 3.141593 -53.000000 Разумеется, в качестве индекса можно использовать переменные: z &lt;- c(3, 2) x[z] ## [1] 3.141593 0.000000 y[z] ## [1] &quot;Санкт Петербург&quot; &quot;Пермь&quot; Кроме того, в качесвте индекса можно использовать вектор логических значений: x[c(TRUE, FALSE, TRUE, TRUE, FALSE)] ## [1] 3.000000 3.141593 23.400000 А это в свою очередь означает, что в качестве индекса можно использовать вектор TRUE/FALSE, получающийся в результате сранвения: x[x &gt; 2] ## [1] 3.000000 3.141593 23.400000 Это работает потому что выражение x &gt; 2 вектор логических значений: x &gt; 2 ## [1] TRUE FALSE TRUE TRUE FALSE Как мы обсуждали раньше оператор ! может перевернуть все логические значения на противоположные: x[!(x &gt; 2)] ## [1] 0 -53 Сколько элементов в векторе g, если выражение g[pi &lt; 1000] не возвращает ошибки? Во встроенном датасете Nile содержаться данные о ежегодном разливе Нила в 1871–1970 годах (в миллиардах кубических метров). Сколько в датасете наблюдений больше 1000 и меньше 1200. 2.9.4 Пропущенные значения Иногда в процессе сбора данных возникают пропущенные значения. Для представления таких данных в R используется последовательность NA: NA ## [1] NA c(1, NA, 9) ## [1] 1 NA 9 c(&quot;Нижний Новгород&quot;, NA, &quot;Санкт Петербург&quot;) ## [1] &quot;Нижний Новгород&quot; NA &quot;Санкт Петербург&quot; c(TRUE, FALSE, NA) ## [1] TRUE FALSE NA Функция is.na проверяет, есть ли в векторе пропущенные значения: x &lt;- c(&quot;Нижний Новгород&quot;, NA, &quot;Санкт Петербург&quot;) y &lt;- c(&quot;Нижний Новгород&quot;, &quot;Пермь&quot;, &quot;Санкт Петербург&quot;) is.na(x) ## [1] FALSE TRUE FALSE is.na(y) ## [1] FALSE FALSE FALSE Некоторые функции не работают с векторами, которые содержат пропущенные значения, и имеют аргумент для их удаления na.rm = TRUE: x &lt;- c(1, NA, 9, 5) mean(x) ## [1] NA mean(x, na.rm = TRUE) ## [1] 5 min(x, na.rm = TRUE) ## [1] 1 max(x, na.rm = TRUE) ## [1] 9 median(x, na.rm = TRUE) ## [1] 5 range(x, na.rm = TRUE) ## [1] 1 9 Сколько элементов в векторе g, если выражение g[pi &lt; 1000] не возвращает ошибки? References "]
]
