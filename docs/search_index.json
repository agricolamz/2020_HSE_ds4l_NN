[
["index.html", "Основы анализа данных 1 Требования 1.1 Домашние работы", " Основы анализа данных Г. Мороз 2020-2021 1 Требования Чтобы работать в классе, необходимо установить следующие программы: R можно найти здесь: https://cloud.r-project.org/; RStudio можно найти здесь: https://rstudio.com/products/rstudio/download/#download (бесплатную версию!); после установки откройте RStudio и наберите 2+2. Если Вы видите что-то такое, значит все хорошо. Пройдите на сайт https://rstudio.cloud/ и зарегестрируйтесь. Это опционально, но если у Вас что-то не будет работать на Вашем компьютере, можно воспользоваться этой опцией. Еще один вариант, позволяющий ничего не устонавливать – это использовать Google Colaboratory (по этой ссылке) Можно не посещать занятия и не делать домашние задания если Вы пройдете следующие онлайн курсы: Introduction to R Data Manipulation with dplyr Introduction to Data Visualization with ggplot2 Если Вы хотите пройти какие-то другие курсы на datacamp (не обязательно связанные с R), можете написать мне, я добавлю Вас в группу, которая позовляет проходить курсы бесплатно. 1.1 Домашние работы домашняя работа 1 домашняя работа 2 домашняя работа 3 "],
["intro.html", "2 Введение 2.1 Наука о данных 2.2 Не R единым 2.3 Основные этапы исследования 2.4 Введение в RStudio 2.5 R как калькулятор 2.6 Комментарии 2.7 Функции 2.8 Переменные 2.9 Вектор 2.10 Пакеты 2.11 Датафрейм и тиббл 2.12 Импорт данных", " 2 Введение 2.1 Наука о данных Наука о данных — это новая область знаний, которая активно развивается в последнее время. Она находиться на пересечении компьютерных наук, статистики и математики, и трудно сказать, действительно ли это наука. При этом это движение развивается в самых разных научных направлениях, иногда даже оформляясь в отдельную отрасль: биоинформатика вычислительная криминалистика цифровые гуманитарные исследования датажурналистика … Все больше книг “Data Science for …”: psychologists (Hansjörg 2019) immunologists (Thomas and Pallett 2019) business (Provost and Fawcett 2013) public policy (Brooks and Cooper 2013) fraud detection (Baesens, Van Vlasselaer, and Verbeke 2015) … Среди умений датасаентистов можно перечислить следующие: сбор и обработка данных трансформация данных визуализация данных статистическое моделирование данных представление полученных результатов организация всей работы воспроизводимым способом 2.2 Не R единым R (R Core Team 2019) — это один из популярных языков для анализа данных. Однако у него вполне есть и альтернативы: Python (VanderPlas 2016; Grus 2019) Julia (Bezanson et al. 2017) bash (Janssens 2014) java (Brzustowicz 2017) … Кроме того ответы на любые проблемы можно найти в… R for data science (Wickham 2016), онлайн R community stackoverflow рускоязычный телеграм-канал (но там есть правила по задаванию вопросов) телеграм-канал, где собираются все новости по R любой поисковик … 2.3 Основные этапы исследования формулировка гипотез(ы) выбор зависимой и независимых переменных сбор данных работа с данными, которую можно представить следующей схемой: При анализе данных бывают разные соблазны, с которыми нужно бороться: Cherry Picking — выбор только тех данных, которые удовлетворяют гипотезе. Data Dredging — проведение множества тестов, пока не появится статистически значимый результат. Систематическая ошибка выжившего — анализ только одной группы объектов (выжившим), так как данных по другой группе (погибшим) данных нет. Ложная корреляция — наличие высокой корреляции между переменными не гарантирует, что между ними есть причино-следственная связь. Неуравновешанная выборка — если выборка неуравновешена, она перестает представлять генеральную совокупность, что может исказить выводы. Чтобы проиллюстрировать этапы исследования давайте возьмем данные из опрос, который вы сейчас пройдете. 2.4 Введение в RStudio R — это язык программироваия. RStudio — наиболее популярный IDE (Integrated Development Environment) для R. Когда вы откроете RStudio первый раз, то увидеть что-то такое: Если нажать наверху на кнопку , то можно будет увидеть все четыре окна: 2.5 R как калькулятор 2+9 ## [1] 11 50*(9-20) ## [1] -550 3^3 ## [1] 27 9^0.5 ## [1] 3 9+0.5 ## [1] 9.5 9+.5 ## [1] 9.5 pi ## [1] 3.141593 Остаток от деления: 10 %% 3 ## [1] 1 Теперь вы готовы решит ваше первое выражение (результат округлите до 3 знаков после запятой): \\[\\frac{\\pi+2}{2^{3-\\pi}}\\] 2.6 Комментарии Любой текст после знака # на той же строчке не исполняется 2+2 # это четыре ## [1] 4 # можно сюда написать комментарий 3+3 ## [1] 6 2.7 Функции Самая важная часть R — функции. Вот некоторые из них: sqrt(4) ## [1] 2 abs(-5) ## [1] 5 sin(pi/2) ## [1] 1 cos(pi) ## [1] -1 sum(2, 3, 9) ## [1] 14 prod(5, 3, 9) ## [1] 135 sin(cos(pi)) ## [1] -0.841471 У каждой функции есть имя и аргументы (от нуля и вверх). Все аргументы перечисляются в круглых скобках, и разделены запятой: round(pi, 2) ## [1] 3.14 Каждый аргумент функции имеет имя и порядковый номер. Если вы используете аргументы функции, вы можете помещать их в любом порядке. Если имена аргументов функции не названы, то их следует перечислять в соответствии с порядковым номером. round(x = pi, digits = 2) ## [1] 3.14 round(digits = 2, x = pi) ## [1] 3.14 round(x = pi, d = 2) ## [1] 3.14 round(d = 2, x = pi) ## [1] 3.14 round(pi, 2) ## [1] 3.14 round(2, pi) # это не то же самое, что на предыдущих строчках! ## [1] 2 Существуют функции без аргументов, но с ними все равно нужно использовать скобки: Sys.Date() # correct ## [1] &quot;2020-10-16&quot; Sys.Date # wrong ## function () ## as.Date(as.POSIXlt(Sys.time())) ## &lt;bytecode: 0x5cb3ac308e88&gt; ## &lt;environment: namespace:base&gt; Все функции в R имеют документацию. Ее можно увидеть, если поставить вопросительный знак перед именем функции: ?Sys.Date Исследуйте следующую функцию log() и посчитайте следующий логарифм: \\[\\log_3(3486784401)\\] 2.8 Переменные Все в R можно хранить в переменной: x &lt;- 5 + 6 В результате работы предыдущей команды, нет никокого результата в консоли, однако новая переменная x окне окружения. Теперь можно использовать эту новую переменную: x + x ## [1] 22 sum(x, x, 7) ## [1] 29 Все эти операции не изменяют значения переменной x. Чтобы изменить значения, нужно сделать новое приписывание: x &lt;- 5 + 6 + 7 Существуют горячие клавиши для создания &lt;- в RStudio: Alt -. Для приписывания значения можно использовать и знак =, однако рекомендуется все же использовать &lt;- для приписывания и знак = для перечисления аргументов функции. Чтобы удалить переменную можно использовать функцию rm(): rm(x) x ## Error in eval(expr, envir, enclos): object &#39;x&#39; not found Переменные бывают разного типа, вот основные: typeof(4.3) # числа ## [1] &quot;double&quot; typeof(&quot;тро-ло-ло&quot;) # строки ## [1] &quot;character&quot; typeof(TRUE) # логические ## [1] &quot;logical&quot; 2.8.1 Сравнение переменных Переменные можно сравнивать: x &lt;- 18 x &gt; 18 ## [1] FALSE x &gt;= 18 ## [1] TRUE x &lt; 100 ## [1] TRUE x &lt;= 18 ## [1] TRUE x == 18 ## [1] TRUE x != 18 ## [1] FALSE Оператор ! изменяет логические значения на противоположные: !TRUE ## [1] FALSE !FALSE ## [1] TRUE !(x &gt; 18) ## [1] TRUE Стоит помнить о логических операциях, которые позволяют соединять разные логические выражения: x &lt;- 5 x &gt; 2 &amp; x &lt; 2 # логическое и ## [1] FALSE x &gt; 10 &amp; x &lt; 100 # логическое и ## [1] FALSE x &gt; 2 | x &lt; 4 # логическое или ## [1] TRUE x &gt; 6 | x &lt; 4 # логическое или ## [1] FALSE 2.9 Вектор Объект в R, который содержит элементы одного типа, называется вектор. Вектор можно создать при помощи функции c(): c(3, 0, pi, 23.4, -53) ## [1] 3.000000 0.000000 3.141593 23.400000 -53.000000 c(&quot;Нижний Новгород&quot;, &quot;Пермь&quot;, &quot;Санкт Петербург&quot;) ## [1] &quot;Нижний Новгород&quot; &quot;Пермь&quot; &quot;Санкт Петербург&quot; c(FALSE, FALSE, TRUE) ## [1] FALSE FALSE TRUE a &lt;- c(2, 3, 4) b &lt;- c(5, 6, 7) c(a, b) ## [1] 2 3 4 5 6 7 Для последовательностей чисел есть и другой способ: 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 3:-5 ## [1] 3 2 1 0 -1 -2 -3 -4 -5 Теперь становится понятно, что все, что мы видели раньше было вектором длины один. Вот почему там все время было [1]: Это индекс элементов в R. Посмотрите: 1:60 ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ## [26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 ## [51] 51 52 53 54 55 56 57 58 59 60 60:1 ## [1] 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 ## [26] 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 ## [51] 10 9 8 7 6 5 4 3 2 1 На этом месте также должно стать очевидно, что в отличие от кучи языков программирования R считает с 1, а не с 0. Для того чтобы создавать арифметические прогресии существует функция seq(): 1:20 ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 seq(from = 1, to = 20, by = 1) ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 seq(from = 2, to = 100, by = 13) ## [1] 2 15 28 41 54 67 80 93 Используйте аргумент length.out функции seq(), чтобы создать арифметическую прогрессию от \\(\\pi\\) до \\(2\\pi\\) длины 50. Кроме того в R есть какое-то количество встроенных векторов: letters ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; ## [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; LETTERS ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; ## [20] &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; month.name ## [1] &quot;January&quot; &quot;February&quot; &quot;March&quot; &quot;April&quot; &quot;May&quot; &quot;June&quot; ## [7] &quot;July&quot; &quot;August&quot; &quot;September&quot; &quot;October&quot; &quot;November&quot; &quot;December&quot; month.abb ## [1] &quot;Jan&quot; &quot;Feb&quot; &quot;Mar&quot; &quot;Apr&quot; &quot;May&quot; &quot;Jun&quot; &quot;Jul&quot; &quot;Aug&quot; &quot;Sep&quot; &quot;Oct&quot; &quot;Nov&quot; &quot;Dec&quot; 2.9.1 Приведение типов По определению вектор может содержать только единицы одного типа. Но что происходит, если соединить элементы разных типов? c(1, &quot;34&quot;) ## [1] &quot;1&quot; &quot;34&quot; c(1, TRUE) ## [1] 1 1 c(TRUE, &quot;34&quot;) ## [1] &quot;TRUE&quot; &quot;34&quot; Мы видим иерархию: строки &gt; числа &gt; логические выражения. Это не универсально между разными языками программирования. Также это не зависит от количество элементов того или иного типа: c(1, 2, 3, &quot;34&quot;) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;34&quot; c(1, TRUE, FALSE, FALSE) ## [1] 1 1 0 0 Приведение типов может случится, во время выполнения и других операций: 5+TRUE ## [1] 6 2.9.2 Операции с векторами и векторизованные операции Все операции, которые мы раньше обсуждали, можно сделать с векторами одинаковой длины: 1:5 + 6:10 ## [1] 7 9 11 13 15 1:5 - 6:10 ## [1] -5 -5 -5 -5 -5 1:5 * 6:10 ## [1] 6 14 24 36 50 Если один из векторов имеет длинну один, то получится так называемая векторизованная операция — операция произойдет с каждым элементом вектора: 1:5 + 7 ## [1] 8 9 10 11 12 1:5 - 7 ## [1] -6 -5 -4 -3 -2 1:5 / 7 ## [1] 0.1428571 0.2857143 0.4285714 0.5714286 0.7142857 В R очень много векторизованных функций: sin(1:5) ## [1] 0.8414710 0.9092974 0.1411200 -0.7568025 -0.9589243 sqrt(1:5) ## [1] 1.000000 1.414214 1.732051 2.000000 2.236068 abs(-5:3) ## [1] 5 4 3 2 1 0 1 2 3 2.9.3 Индексирование вектора Как получить какое-то значение или несколько значений из вектора? Нужно использовать индекс: x &lt;- c(3, 0, pi, 23.4, -53) y &lt;- c(&quot;Нижний Новгород&quot;, &quot;Пермь&quot;, &quot;Санкт Петербург&quot;) x[4] ## [1] 23.4 y[2] ## [1] &quot;Пермь&quot; Вектор можно использовать в качестве индекса: x[1:2] ## [1] 3 0 y[c(1, 3)] ## [1] &quot;Нижний Новгород&quot; &quot;Санкт Петербург&quot; Отрицательный индекс исключает элементы из вектора: y[-2] ## [1] &quot;Нижний Новгород&quot; &quot;Санкт Петербург&quot; x[-c(1, 4)] ## [1] 0.000000 3.141593 -53.000000 Разумеется, в качестве индекса можно использовать переменные: z &lt;- c(3, 2) x[z] ## [1] 3.141593 0.000000 y[z] ## [1] &quot;Санкт Петербург&quot; &quot;Пермь&quot; Кроме того, в качесвте индекса можно использовать вектор логических значений: x[c(TRUE, FALSE, TRUE, TRUE, FALSE)] ## [1] 3.000000 3.141593 23.400000 А это в свою очередь означает, что в качестве индекса можно использовать вектор TRUE/FALSE, получающийся в результате сранвения: x[x &gt; 2] ## [1] 3.000000 3.141593 23.400000 Это работает потому что выражение x &gt; 2 вектор логических значений: x &gt; 2 ## [1] TRUE FALSE TRUE TRUE FALSE Как мы обсуждали раньше оператор ! может перевернуть все логические значения на противоположные: x[!(x &gt; 2)] ## [1] 0 -53 Сколько элементов в векторе g, если выражение g[pi &lt; 1000] не возвращает ошибки? Во встроенном датасете Nile содержаться данные о ежегодном разливе Нила в 1871–1970 годах (в миллиардах кубических метров). Сколько в датасете наблюдений больше 1000 и меньше 1200. 2.9.4 Пропущенные значения Иногда в процессе сбора данных возникают пропущенные значения. Для представления таких данных в R используется последовательность NA: NA ## [1] NA c(1, NA, 9) ## [1] 1 NA 9 c(&quot;Нижний Новгород&quot;, NA, &quot;Санкт Петербург&quot;) ## [1] &quot;Нижний Новгород&quot; NA &quot;Санкт Петербург&quot; c(TRUE, FALSE, NA) ## [1] TRUE FALSE NA Функция is.na проверяет, есть ли в векторе пропущенные значения: x &lt;- c(&quot;Нижний Новгород&quot;, NA, &quot;Санкт Петербург&quot;) y &lt;- c(&quot;Нижний Новгород&quot;, &quot;Пермь&quot;, &quot;Санкт Петербург&quot;) is.na(x) ## [1] FALSE TRUE FALSE is.na(y) ## [1] FALSE FALSE FALSE Некоторые функции не работают с векторами, которые содержат пропущенные значения, и имеют аргумент для их удаления na.rm = TRUE: x &lt;- c(1, NA, 9, 5) mean(x) ## [1] NA mean(x, na.rm = TRUE) ## [1] 5 min(x, na.rm = TRUE) ## [1] 1 max(x, na.rm = TRUE) ## [1] 9 median(x, na.rm = TRUE) ## [1] 5 range(x, na.rm = TRUE) ## [1] 1 9 Сколько элементов в векторе g, если выражение g[pi &lt; 1000] не возвращает ошибки? 2.10 Пакеты Самая большая ценность R не в нем самом, а в пакетах, которые написаны для этого языка. Более ли менее, все, что мы пока обсуждали — основной механизм работы R, который разработали еще в 1979. С тех пор много чего поменялось, так что все новые практики в анализе и трансформации данных хранятся в пакетах — отдельный модуль, после загрузки которого в окружении R появляются дополнительные функции. Мы изучим наиболее популярный диалект R, который называется tidyverse (альтернатива – пакет data.table). Для установки пакета следует использовать функцию install.packages() install.packages(&quot;tidyverse&quot;) Сегодня нам еще понадобиться пакет readxl: install.packages(&quot;readxl&quot;) После того, как пакет установлен, его можно включить: library(&quot;tidyverse&quot;) ## ── Attaching packages ──────── ## ✓ ggplot2 3.3.2 ✓ purrr 0.3.4 ## ✓ tibble 3.0.3 ✓ dplyr 1.0.2 ## ✓ tidyr 1.1.2 ✓ stringr 1.4.0 ## ✓ readr 1.3.1 ✓ forcats 0.5.0 ## ── Conflicts ───────────────── ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() Не загрузка пакета — самая частая ошибка студентов: install.packages(\"...\") — это как купить набор отверток; library(\"...\") — это как собрать и быть готовым использовать купленный набор. Установите пакеты tidyverse и readxl. К какому пакету принадлежит функция add_column()? dplyr ggplot2 purrr readr readxl tibble tidyr 2.11 Датафрейм и тиббл Датафрейм — это собрание векторов одинаковой длины с уникальными названиями. Вот пример датафрейма с фильмографией Тома Мура: moore_filmography &lt;- tibble(title = c(&quot;The Secret of Kells&quot;, &quot;Song of the Sea&quot;, &quot;Kahlil Gibran&#39;s The Prophet&quot;, &quot;The Breadwinner&quot;, &quot;Wolfwalkers&quot;), year = c(2009, 2014, 2014, 2017, 2020), director = c(TRUE, TRUE, TRUE, FALSE, TRUE)) moore_filmography Существует много встроенных датафреймов: mtcars iris О них точно также модно найти информацию в справке: ?mtcars ?iris Элементы датафрейма – векторы – можно вызывать используя знак $: moore_filmography$year ## [1] 2009 2014 2014 2017 2020 moore_filmography$title ## [1] &quot;The Secret of Kells&quot; &quot;Song of the Sea&quot; ## [3] &quot;Kahlil Gibran&#39;s The Prophet&quot; &quot;The Breadwinner&quot; ## [5] &quot;Wolfwalkers&quot; К существующему датафрейму можно добавить новый вектор: moore_filmography$producer &lt;- c(TRUE, TRUE, FALSE, TRUE, TRUE) moore_filmography Существует масса полезных функций, которые говорят что-то о датафрейме: nrow(moore_filmography) ## [1] 5 ncol(moore_filmography) ## [1] 4 summary(moore_filmography) ## title year director producer ## Length:5 Min. :2009 Mode :logical Mode :logical ## Class :character 1st Qu.:2014 FALSE:1 FALSE:1 ## Mode :character Median :2014 TRUE :4 TRUE :4 ## Mean :2015 ## 3rd Qu.:2017 ## Max. :2020 str(moore_filmography) ## tibble [5 × 4] (S3: tbl_df/tbl/data.frame) ## $ title : chr [1:5] &quot;The Secret of Kells&quot; &quot;Song of the Sea&quot; &quot;Kahlil Gibran&#39;s The Prophet&quot; &quot;The Breadwinner&quot; ... ## $ year : num [1:5] 2009 2014 2014 2017 2020 ## $ director: logi [1:5] TRUE TRUE TRUE FALSE TRUE ## $ producer: logi [1:5] TRUE TRUE FALSE TRUE TRUE Мы будем работать исключительно с датафреймами (однако, это не единственная структура данных в R). Сколько строчек в датасете iris? Сколько колонок в датасете mtcars? 2.11.1 Вызов элементов датафрейма Датафрейм — двумерный объект, так что можно вызывать как его строчки, так и его колонки. Это делается при помощи квадратных скобок и индексов: первый отвечает за строчки, второй – за колонки: moore_filmography[3, 2] moore_filmography[3,] moore_filmography[,2] moore_filmography[,1:2] moore_filmography[,-3] moore_filmography[,-c(1:2)] moore_filmography[,&quot;year&quot;] moore_filmography[,c(&quot;title&quot;, &quot;year&quot;)] moore_filmography[moore_filmography$year &gt; 2014,] 2.12 Импорт данных 2.12.1 .csv файлы .csv файлы (comma-separated values) — это текст, разделенный запятыми (или другими разделителями, например, табуляцией или точкой с запятой) на отдельные значения. Его широко используют, так как его одинаково легко редактировать людям и парсить компьютерам. Вот датасет moore_filmography в формате .csv: title,year,director,producer The Secret of Kells,2009,TRUE,TRUE Song of the Sea,2014,TRUE,TRUE Kahlil Gibran&#39;s The Prophet,2014,TRUE,FALSE The Breadwinner,2017,FALSE,TRUE Wolfwalkers,2020,TRUE,TRUE Давайте создадим переменную с этими данными: our_csv &lt;- &quot;title,year,director,producer The Secret of Kells,2009,TRUE,TRUE Song of the Sea,2014,TRUE,TRUE Kahlil Gibran&#39;s The Prophet,2014,TRUE,FALSE The Breadwinner,2017,FALSE,TRUE Wolfwalkers,2020,TRUE,TRUE&quot; Теперь мы можем использовать функцию read_csv() (из tidyverse): read_csv(our_csv) Так же вы можете загрузить файл с компьютера. Скачайте этот файл на компьютер (нажмите Ctrl S или Cmd S) и считайте его в: read_csv(&quot;C:/path/to/your/file/moore_filmography.csv&quot;) Еще файл можно скачать непосредственно из интернета: read_csv(&quot;https://raw.githubusercontent.com/agricolamz/2020_HSE_ds4l_NN/master/data/moore_filmography.csv&quot;) ## Parsed with column specification: ## cols( ## title = col_character(), ## year = col_double(), ## director = col_logical(), ## producer = col_logical() ## ) Из-за пандемии про Ухань говорили во всех новостях. По-русски по каким-то причинам этот город носители относят то к мужскому роду, то к женскому. Я посмотрел на другие славянские языки и записал полученные данные в .csv file. Скачайте датасет в R. Какие там переменные? Все операции с файлами в R как-то связаны с памятью вашего компьютера. Чтобы узнать папку, в которой R находится, можно запустить команду getwd(). Рабочую дерикторию можно поменять, используя функцию setwd(). Если файл, с которым Вы хотите работать находится в рабочей дериктории, то нет нужды писать полный путь к файлу: read_csv(&quot;moore_filmography.csv&quot;) Кроме того, естественно, в R существует функция, которая позволяет записывать .csv: write_csv(moore_filmography, &quot;moore_filmography_v2.csv&quot;) Иногда чтение .csv файлов в Microsoft Excel вызывает какие-то трудности, посмотрите инструкции, если у кого-то возникнут похожие проблемы. 2.12.2 файлы .xls и .xlsx Для чтения файлов .xsl and .xslx существует пакет readxl. Установите и загрузите библиотеку: library(readxl) Вот тестовый файл. Скачайте его к себе на компьютер, положите в рабочую дерикторию и загрузите в R: read_xlsx(&quot;moore_filmography.xlsx&quot;) .xls и .xlsx могут иметь разные таблиц на разных листах: read_xlsx(&quot;moore_filmography.xlsx&quot;, sheet = &quot;iris&quot;) References "],
["трансформация-данных-с-dplyr-и-tidyr.html", "3 Трансформация данных с dplyr и tidyr 3.1 Данные 3.2 dplyr 3.3 Объединение датафреймов 3.4 Пакет tidyr", " 3 Трансформация данных с dplyr и tidyr Загрузим библиотеку: library(tidyverse) 3.1 Данные 3.1.1 Датасет с опечатками Этот датасет получен после обработки данных из статьи The Gyllenhaal Experiment Расселла Голденберга и Мэта Даниэлса для pudding. Они анализировали опечатки, которые делают пользователи, когда ищут информацию про знаменитостей. misspellings &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/2020_HSE_ds4l_NN/master/data/misspelling_dataset.csv&quot;) ## Parsed with column specification: ## cols( ## correct = col_character(), ## spelling = col_character(), ## count = col_double() ## ) misspellings В датасете следующие колонки: correct — правильное написание spelling — написание пользователей count — количество написаний (из колонки spelling) в датасете 3.1.2 diamonds diamonds — это датасет встроенный в пакет tidyverse. diamonds ?diamonds 3.2 dplyr Здесь и здесь находятся щпаргалки про dplyr. 3.2.1 filter() Эта функция фильтрует строчки согласно некоторому условию. Какие произнесения были использованы меньше чем 10 ползователями? misspellings %&gt;% filter(count &lt; 10) %&gt;% — это конвеера (по-русски, еще называют пайпом или шуточно велосипедом). Горячая клавиши для вызова конвеера Ctrl Shift M. Конвеер позволяет создавать цепочки операций, так что результат работы одной функции становится инпутом для работы следующей функции. Сравните: sort(sqrt(abs(sin(1:22))), decreasing = TRUE) ## [1] 0.9999951 0.9952926 0.9946649 0.9805088 0.9792468 0.9554817 0.9535709 ## [8] 0.9173173 0.9146888 0.8699440 0.8665952 0.8105471 0.8064043 0.7375779 ## [15] 0.7325114 0.6482029 0.6419646 0.5365662 0.5285977 0.3871398 0.3756594 ## [22] 0.0940814 1:22 %&gt;% sin() %&gt;% abs() %&gt;% sqrt() %&gt;% sort(decreasing = TRUE) ## [1] 0.9999951 0.9952926 0.9946649 0.9805088 0.9792468 0.9554817 0.9535709 ## [8] 0.9173173 0.9146888 0.8699440 0.8665952 0.8105471 0.8064043 0.7375779 ## [15] 0.7325114 0.6482029 0.6419646 0.5365662 0.5285977 0.3871398 0.3756594 ## [22] 0.0940814 Конвееры широко используются внутри tidyverse и могут не всегда работать вне пакетов экосистемы: Так что функция filter() вовзращает строчки, подходящие некоторому условию: misspellings %&gt;% filter(count &lt; 10) Можно использовать несколько условий. Какие произнесения Deschanel было использовано меньше чем 10 ползователями? misspellings %&gt;% filter(count &lt; 10, correct == &quot;deschanel&quot;) Кроме того в этой функции можно использовать условие с ИЛИ. Какие произнесения были использовано меньше чем 10 ИЛИ более чем 500 пользователями? misspellings %&gt;% filter(count &lt; 10 | count &gt; 500) 3.2.2 slice() Эта функция фильтрует строчки на основе их индекса. misspellings %&gt;% slice(3:7) 3.2.3 select() Эта функция выбирает переменные в датафрейме на основе их имени или индекса. diamonds %&gt;% select(8:10) diamonds %&gt;% select(color:price) diamonds %&gt;% select(-carat) diamonds %&gt;% select(-c(carat, cut, x, y, z)) diamonds %&gt;% select(cut, depth, price) 3.2.4 arrange() Эта функция сортирует строчки в датафрейме (числа — по возрастанию/убыванию, строки — по алфавиту). misspellings %&gt;% arrange(count) diamonds %&gt;% arrange(desc(carat), price) diamonds %&gt;% arrange(-carat, price) 3.2.5 distinct() Эта функция возвращает уникальные строчки из датафрейма. misspellings %&gt;% distinct(correct) misspellings %&gt;% distinct(spelling) diamonds %&gt;% distinct(color, cut) Отфильтруйте во встроенном датасете starwars героев, которые выше 180, имеют массу меньше 80. Сколько уникальных планет происхождения этих героев (переменная homeworld)? 3.2.6 mutate() Эта функция создает новые переменные или позволяет изменять старые. misspellings %&gt;% mutate(misspelling_length = nchar(spelling), id = 1:n()) Создайте переменную с индексом массы тела: \\(\\frac{mass}{height^2}\\) для всех героев из датасета starwars. Сколько героев страдают ожирением (имеют индекс массы тела больше 30)? (Не забудьте перевести рост героев из сантиметров в метры). 3.2.7 group_by(...) %&gt;% summarise(...) Эти функции позволяют сгруппировать переменные по какой-то переменной в одном из столбцов датафрейма и получить какое обобщение (например, максимум, минимум, последнее значение, среднее, медиану и др.) misspellings %&gt;% summarise(min(count), mean(count)) misspellings %&gt;% group_by(correct) %&gt;% summarise(mean(count)) ## `summarise()` ungrouping output (override with `.groups` argument) misspellings %&gt;% group_by(correct) %&gt;% summarise(my_mean = mean(count)) ## `summarise()` ungrouping output (override with `.groups` argument) Если нужно посчитать количество наблюдений в группе, используйте функцию n() внутри summarise() или функцию count(): misspellings %&gt;% group_by(correct) %&gt;% summarise(n = n()) ## `summarise()` ungrouping output (override with `.groups` argument) misspellings %&gt;% count(correct) Результат можно отсортировать, используя аргумент sort: misspellings %&gt;% count(correct, sort = TRUE) Бывают случаи, когда не хочется иметь отдельное саммари, а хочется добавить полученную информацию в новую колонку, для этого можно вместо summarise() использовать mutate() misspellings %&gt;% group_by(correct) %&gt;% mutate(my_mean = mean(count)) Вот схема: В датасете starwars создайте переменную, содержащую среднее значение роста (height) для каждого вида (species). 3.3 Объединение датафреймов 3.3.1 bind_... Это семейство фукнций, который позволяет объединять датасеты: my_tbl &lt;- tibble(a = c(1, 5, 2), b = c(&quot;e&quot;, &quot;g&quot;, &quot;s&quot;)) Здесь датасеты объеденены по строчкам: my_tbl %&gt;% bind_rows(my_tbl) Если какой-то из колонок не хватает, то нехватающие значения будут заполнены NA: my_tbl %&gt;% bind_rows(my_tbl[,-1]) Вот так можно соединить датафреймы по колонкам: my_tbl %&gt;% bind_cols(my_tbl) ## New names: ## * a -&gt; a...1 ## * b -&gt; b...2 ## * a -&gt; a...3 ## * b -&gt; b...4 Если количество строчек будет разным функция вернет ошибку: my_tbl %&gt;% bind_cols(my_tbl[-1,]) ## Error: Can&#39;t recycle `..1` (size 3) to match `..2` (size 2). 3.3.2 .._join() Данное семейство функций позволяет объединять датафреймы на основании некоторой общей колонки или набора общих колонок. languages &lt;- tibble( languages = c(&quot;Selkup&quot;, &quot;French&quot;, &quot;Chukchi&quot;, &quot;Polish&quot;), countries = c(&quot;Russia&quot;, &quot;France&quot;, &quot;Russia&quot;, &quot;Poland&quot;), iso = c(&quot;sel&quot;, &quot;fra&quot;, &quot;ckt&quot;, &quot;pol&quot;) ) languages country_population &lt;- tibble( countries = c(&quot;Russia&quot;, &quot;Poland&quot;, &quot;Finland&quot;), population_mln = c(143, 38, 5)) country_population inner_join(languages, country_population) ## Joining, by = &quot;countries&quot; left_join(languages, country_population) ## Joining, by = &quot;countries&quot; right_join(languages, country_population) ## Joining, by = &quot;countries&quot; anti_join(languages, country_population) ## Joining, by = &quot;countries&quot; anti_join(country_population, languages) ## Joining, by = &quot;countries&quot; full_join(country_population, languages) ## Joining, by = &quot;countries&quot; 3.4 Пакет tidyr Перед нами датасет с количеством носителей некоторых языков Индии according the census 2001 (data from Wikipedia): langs_in_india_short &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/2020.02_Naumburg_R/master/data/languages_in_india.csv&quot;) ## Parsed with column specification: ## cols( ## language = col_character(), ## n_L1_sp = col_double(), ## n_L2_sp = col_double(), ## n_L3_sp = col_double(), ## n_all_sp = col_double() ## ) Широкий формат langs_in_india_short Длинный формат Широкий формат → длинный формат: tidyr::pivot_longer() langs_in_india_short %&gt;% pivot_longer(names_to = &quot;type&quot;, values_to = &quot;n_speakers&quot;, n_L1_sp:n_all_sp)-&gt; langs_in_india_long langs_in_india_long Длинный формат → шиирокий формат: tidyr::pivot_wider() langs_in_india_long %&gt;% pivot_wider(names_from = &quot;type&quot;, values_from = &quot;n_speakers&quot;)-&gt; langs_in_india_short langs_in_india_short 3.4.1 Концепция tidy data Одни и те же данные можно представить разными способами. Основная философия tidyverse построена вокруг понятия tidy data: Каждая переменная содержится в отдельном столбце. Каждое наблюдение содержится в отдельной строчке. Каждое значение записано в свою ячейку. Здесь находятся данные содержащие информацию о деревнях в Дагестане в формате .xlsx. Данные разделены на разные листы и содержат разные переменные (данные полученные из разных источников, так что у них переменных есть префикс _s1 – первый источник; и _s2 – второй источник): id_s1 – (s1) id из первого источника; name_1885 – (s1) название деревни по переписи 1885 census_1885 – (s1) количество людей по переписи 1885 name_1895 – (s1) название деревни по переписи 1895 census_1895 – (s1) количество людей по переписи 1895 name_1926 – (s1) название деревни по переписи 1926 census_1926 – (s1) количество людей по переписи 1926 name_2010 – (s1) название деревни по переписи 2010 census_2010 – (s1) количество людей по переписи2010 language_s1 – (s1) язык, на котором говорят в деревне согласно первому источнику name_s2 – (s2) название деревни согласно второму источнику language_s2 – (s2) язык, на котором говорят в деревне согласно второму источнику Lat – (s2) широта Lon – (s2) долгота elevation – (s2) высота Соедините все эти разные таблицы из .xlsx: Посчитайте сколько раз языки совпадают в двух источниках (переменные language_s1 и language_s2). Посчитайте среднюю высоту для языков из первого источника, какой выше? Посчитайте количество носителей разных языков (согласно второму источнику) для каждой переписи. Покажите значение для лакского языка: "],
["viz-1.html", "4 Визуализация данных 4.1 Зачем визуализировать данные? 4.2 Основы ggplot2 4.3 Столбчатые диаграммы (barplots) 4.4 Факторы 4.5 Гистограммы 4.6 Функции плотности 4.7 Точки, джиттер (jitter), вайолинплот (violinplot), ящики с усами (boxplot), 4.8 Фасетизация", " 4 Визуализация данных library(&quot;tidyverse&quot;) 4.1 Зачем визуализировать данные? 4.1.1 Квартет Анскомба В работе Anscombe, F. J. (1973). “Graphs in Statistical Analysis” представлен следующий датасет: quartet &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/data/anscombe.csv&quot;) quartet quartet %&gt;% group_by(dataset) %&gt;% summarise(mean_X = mean(x), mean_Y = mean(y), sd_X = sd(x), sd_Y = sd(y), cor = cor(x, y), n_obs = n()) %&gt;% select(-dataset) %&gt;% round(2) 4.1.2 Датазаурус В работе Matejka and Fitzmaurice (2017) “Same Stats, Different Graphs” были представлены следующие датасеты: datasaurus &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/data/datasaurus.csv&quot;) datasaurus datasaurus %&gt;% group_by(dataset) %&gt;% summarise(mean_X = mean(x), mean_Y = mean(y), sd_X = sd(x), sd_Y = sd(y), cor = cor(x, y), n_obs = n()) %&gt;% select(-dataset) %&gt;% round(1) ## `summarise()` ungrouping output (override with `.groups` argument) 4.2 Основы ggplot2 Пакет ggplot2 – современный стандарт для создания графиков в R. Для этого пакета пишут массу расширений. В сжатом виде информация про ggplot2 содержиться здесь. 4.2.1 Диаграмма рассеяния (Scaterplot) ggplot2 ggplot(data = diamonds, aes(carat, price)) + geom_point() dplyr, ggplot2 diamonds %&gt;% ggplot(aes(carat, price))+ geom_point() 4.2.2 Слои diamonds %&gt;% ggplot(aes(carat, price))+ geom_point()+ geom_smooth() ## `geom_smooth()` using method = &#39;gam&#39; and formula &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; diamonds %&gt;% ggplot(aes(carat, price))+ geom_smooth()+ geom_point() ## `geom_smooth()` using method = &#39;gam&#39; and formula &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; 4.2.3 aes() diamonds %&gt;% ggplot(aes(carat, price, color = cut))+ geom_point() diamonds %&gt;% ggplot(aes(carat, price))+ geom_point(color = &quot;green&quot;) diamonds %&gt;% ggplot(aes(carat, price))+ geom_point(aes(color = cut)) diamonds %&gt;% ggplot(aes(carat, price, shape = cut))+ geom_point() diamonds %&gt;% ggplot(aes(carat, price, label = color))+ geom_text() diamonds %&gt;% slice(1:100) %&gt;% ggplot(aes(carat, price, label = color))+ geom_label() Иногда аннотации налезают друг на друга: library(ggrepel) diamonds %&gt;% slice(1:100) %&gt;% ggplot(aes(carat, price, label = color))+ geom_text_repel() diamonds %&gt;% slice(1:100) %&gt;% ggplot(aes(carat, price, label = color))+ geom_text_repel()+ geom_point() diamonds %&gt;% slice(1:100) %&gt;% ggplot(aes(carat, price, label = color, fill = cut))+ # fill отвечает за закрашивание geom_label_repel(alpha = 0.5)+ # alpha отвечает за прозрачность geom_point() 4.2.4 Оформление diamonds %&gt;% ggplot(aes(carat, price, color = cut))+ geom_point() + labs(x = &quot;вес (в каратах)&quot;, y = &quot;цена (в долларах)&quot;, title = &quot;Связь цены и веса бриллиантов&quot;, subtitle = &quot;Данные взяты из датасеты diamonds&quot;, caption = &quot;график сделан при помощи пакета ggplot2&quot;)+ theme(legend.position = &quot;bottom&quot;) # у функции theme() огромный функционал 4.2.5 Логарифмические шкалы Рассмотрим словарь [Ляшевской, Шарова 2011] freqdict &lt;- read_tsv(&quot;https://github.com/agricolamz/DS_for_DH/raw/master/data/freq_dict_2011.csv&quot;) ## Parsed with column specification: ## cols( ## lemma = col_character(), ## pos = col_character(), ## freq_ipm = col_double() ## ) freqdict %&gt;% arrange(desc(freq_ipm)) %&gt;% mutate(id = 1:n()) %&gt;% slice(1:150) %&gt;% ggplot(aes(id, freq_ipm))+ geom_point() freqdict %&gt;% arrange(desc(freq_ipm)) %&gt;% mutate(id = 1:n()) %&gt;% slice(1:150) %&gt;% ggplot(aes(id, freq_ipm, label = lemma))+ geom_point()+ geom_text_repel()+ scale_y_log10() 4.2.6 annotate() Функция annotate добавляет geom к графику. diamonds %&gt;% ggplot(aes(carat, price, color = cut))+ geom_point()+ annotate(geom = &quot;rect&quot;, xmin = 4.8, xmax = 5.2, ymin = 17500, ymax = 18500, fill = &quot;red&quot;, alpha = 0.2) + annotate(geom = &quot;text&quot;, x = 4.7, y = 16600, label = &quot;помогите...\\n я в розовом\\nквадратике&quot;) Скачайте вот этот датасет и постройте диаграмму рассеяния. 4.3 Столбчатые диаграммы (barplots) Одна и та же информация может быть представлена в агрегированном и не агрегированном варианте: misspelling &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/data/misspelling_dataset.csv&quot;) ## Parsed with column specification: ## cols( ## correct = col_character(), ## spelling = col_character(), ## count = col_double() ## ) misspelling переменные spelling аггрегирована: для каждого значения представлено значение в столбце count, которое обозначает количество каждого из написаний переменные correct неаггрегированы: в этом столбце она повторяется, для того, чтобы сделать вывод, нужно отдельно посчитать количество вариантов Для аггрегированных данных используется geom_col() misspelling %&gt;% slice(1:20) %&gt;% ggplot(aes(spelling, count))+ geom_col() Перевернем оси: misspelling %&gt;% slice(1:20) %&gt;% ggplot(aes(spelling, count))+ geom_col()+ coord_flip() Для неаггрегированных данных используется geom_bar() misspelling %&gt;% ggplot(aes(correct))+ geom_bar() Перевернем оси: misspelling %&gt;% ggplot(aes(correct))+ geom_bar()+ coord_flip() Неаггрегированный вариант можно перевести в аггрегированный: diamonds %&gt;% count(cut) Аггрегированный вариант можно перевести в неаггрегированный: diamonds %&gt;% count(cut) %&gt;% uncount(n) 4.4 Факторы Как можно заметить по предыдущему разделу, переменные на графике упорядочены по алфавиту. Чтобы это исправить нужно обсудить факторы: my_factor &lt;- factor(misspelling$correct) head(my_factor) ## [1] deschanel deschanel deschanel deschanel deschanel deschanel ## 15 Levels: deschanel galifianakis johansson kaepernick labeouf ... shyamalan levels(my_factor) ## [1] &quot;deschanel&quot; &quot;galifianakis&quot; &quot;johansson&quot; &quot;kaepernick&quot; &quot;labeouf&quot; ## [6] &quot;macaulay&quot; &quot;mcconaughey&quot; &quot;mcgwire&quot; &quot;mclachlan&quot; &quot;minaj&quot; ## [11] &quot;morissette&quot; &quot;palahniuk&quot; &quot;picabo&quot; &quot;poehler&quot; &quot;shyamalan&quot; levels(my_factor) &lt;- rev(levels(my_factor)) head(my_factor) ## [1] shyamalan shyamalan shyamalan shyamalan shyamalan shyamalan ## 15 Levels: shyamalan poehler picabo palahniuk morissette minaj ... deschanel misspelling %&gt;% mutate(correct = factor(correct, levels = c(&quot;deschanel&quot;, &quot;galifianakis&quot;, &quot;johansson&quot;, &quot;kaepernick&quot;, &quot;labeouf&quot;, &quot;macaulay&quot;, &quot;mcgwire&quot;, &quot;mclachlan&quot;, &quot;minaj&quot;, &quot;morissette&quot;, &quot;palahniuk&quot;, &quot;picabo&quot;, &quot;poehler&quot;, &quot;shyamalan&quot;, &quot;mcconaughey&quot;))) %&gt;% ggplot(aes(correct))+ geom_bar()+ coord_flip() Для работы с факторами удобно использовать пакет forcats (входит в tidyverse, вот ссылка на cheatsheet). Иногда полезной бывает функция fct_reorder(): misspelling %&gt;% count(correct) misspelling %&gt;% count(correct) %&gt;% ggplot(aes(fct_reorder(correct, n), n))+ geom_col()+ coord_flip() Кроме того, в функцию fct_reorder() можно добавит функцию, которая будет считаться на векторе, по которому группируют: diamonds %&gt;% mutate(cut = fct_reorder(cut, price, mean)) %&gt;% ggplot(aes(cut)) + geom_bar() В этом примере переменная cut упорядочена по средней mean цене price. Естественно, вместо mean можно использовать другие функции (median, min, max или даже собственные функции). Можно совмещать разные geom_...: misspelling %&gt;% count(correct) %&gt;% ggplot(aes(fct_reorder(correct, n), n, label = n))+ geom_col()+ geom_text(nudge_y = 150)+ coord_flip() На Pudding вышла статья про английские пабы. Здесь лежит немного обработанный датасет, которые они использовали. Визуализируйте 30 самых частотоных названий пабов в Великобритании. 📋 список подсказок ➡ На новостном портале meduza.io недавно вышла новость о применения закона “о неуважении к власти в интернете”. Постройте графики из этой новости. При построении графиков я использовал цвет “tan3”. `{r, results=‘asis’, echo = FALSE} check_hints(list_title = “📋 список подсказок ➡”, hint_title = c(“А ссылка на датафрейм, где все посчитано?”, “Не понятно, а что это за geom_ такой линия с точкой?”, “Почему все рисуется в алфавитном порядке?”, “Почему точки рисуются, а линия не хочет? Спойлер: самим тут не справиться.”, “Ой, а как добавить белое окружение вокруг точек?”, “Кажется все?”), hint_text = c(“А ее нет. Вам надо самим создать датафрейм. Вспоммнайте функцию tibble().”, “Такого geom_-а нет. Нужно использовать три geom_-а: geom_point(), geom_text() и geom_line().”, “Здесь нужно использовать функцию factor(), чтобы задать эксплицитный порядок.”, “Действительно, здесь спрятана хитрость: ggplot не знает как ему соединить имеющиеся точки, поэтому чтобы все заработало нужно создать новую переменную в датафрейме (например, type = 1), а в функции aes() вставить аргумент group = type. Тогда ggplot объединит линией все, что имеет одно и то же значение в аргументе group.”, “Нужно пойти на военную хитрость: добавить еще один geom_point() белого цвета и большего размера, а потом уже наложить обычные точки. Тут и возникают проблемы с порядокм: сначала нужно нарисовать линию, потом белые точки, а потом уже коричневые. А где должен быть geom_text()?”, “А Вы убрали подписи осей x и y? А подпись добавили?”), hint_title_prefix = “👁”, hint_title_suffix = \" ➡\") ## Дотплот Иногда для случаев, когда мы исследуем числовую переменную подходит простой график, который отображает распределение наших наблюдений на одной соответствующей числовой шкале. ```r mtcars %&gt;% ggplot(aes(mpg)) + geom_dotplot(method = &quot;histodot&quot;) ## `stat_bindot()` using `bins = 30`. Pick better value with `binwidth`. По оси x отложена наша переменная, каждая точка – одно наблюдение, а отложенное по оси y стоит игнорировать – оно появляется из-за ограничений пакета ggplot2. Возможно чуть понятнее будет, если добавить geom_rug(), который непосредственно отображает каждое наблюдение. mtcars %&gt;% ggplot(aes(mpg)) + geom_rug()+ geom_dotplot(method = &quot;histodot&quot;) ## `stat_bindot()` using `bins = 30`. Pick better value with `binwidth`. Больший смысл имеет раскрашенный вариант: mtcars %&gt;% mutate(cyl = factor(cyl)) %&gt;% ggplot(aes(mpg, fill = cyl)) + geom_rug()+ geom_dotplot(method = &quot;histodot&quot;)+ scale_y_continuous(NULL, breaks = NULL) # чтобы убрать ось y ## `stat_bindot()` using `bins = 30`. Pick better value with `binwidth`. Как видно, на графике, одна синяя точка попала под одну зеленую: значит они имеют общее наблюдение. 4.5 Гистограммы Если наблюдений слишком много, дотплот не имеем много смысла: diamonds %&gt;% ggplot(aes(price)) + geom_dotplot(method = &quot;histodot&quot;)+ scale_y_continuous(NULL, breaks = NULL) # чтобы убрать ось y ## `stat_bindot()` using `bins = 30`. Pick better value with `binwidth`. diamonds %&gt;% ggplot(aes(price)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Обсудим на предыдущем примере mtcars %&gt;% ggplot(aes(mpg))+ geom_rug()+ geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. По оси x отложена наша переменная, а высота столбца говорит, сколько наблюдений имеют такое же наблюдение. Однако многое зависит от того, что мы считаем одинаковым значением: mtcars %&gt;% ggplot(aes(mpg)) + geom_rug()+ geom_histogram(bins = 100) mtcars %&gt;% ggplot(aes(mpg)) + geom_rug()+ geom_histogram(bins = 5) Существует три алгоритма встроенные в R, которые можно использовать и снимать с себя ответственность: [Sturgers 1926] nclass.Sturges(mtcars$mpg) [Scott 1979] nclass.scott(mtcars$mpg) [Freedman, Diaconis 1981] nclass.FD(mtcars$mpg) mtcars %&gt;% ggplot(aes(mpg)) + geom_histogram(bins = nclass.FD(mtcars$mpg)) Какой из методов использовался при создании следующего графика на основе встроенного датасета iris? В этом типе графика точно так же можно раскрашивать на основании другой переменной: iris %&gt;% ggplot(aes(Petal.Length, fill = Species)) + geom_rug()+ geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. 4.6 Функции плотности Кроме того, существует способ использовать не такой рубленный график, а его сглаженную вариант, ыйторый строиться при помои функции плотядерной оценки ности. Важное свойство, которое стоит понимать про функцию плотности — что кривая, получаемая ядерной оценкой плотности, не зависит от величины коробки гистделения (хотя есть аргумент, который от adjustвечает за степень “близости” функции плотности к гистограмме). iris %&gt;% ggplot(aes(Petal.Length)) + geom_rug()+ geom_density() Таким образом мы можем сравнивать распределения: iris %&gt;% ggplot(aes(Petal.Length, fill = Species)) + geom_rug()+ geom_density() Часто имеет смысл настроить прозрачность: iris %&gt;% ggplot(aes(Petal.Length, fill = Species)) + geom_rug()+ geom_density(alpha = 0.6) # значение прозрачности изменяется от 0 до 1 Кроме того, иногда удобно разделять группы на разные уровни: # install.packages(ggridges) library(ggridges) iris %&gt;% ggplot(aes(Petal.Length, Species, fill = Species)) + geom_density_ridges(alpha = 0.6) # значение прозрачности изменяется от 0 до 1 ## Picking joint bandwidth of 0.155 В длинный список “2015 Kantar Information is Beautiful Awards” попала визуализация Perceptions of Probability, сделанная пользователем zonination в ggplot2. Попробуйте воспроизвести ее с этими данными. 📋 список подсказок ➡ 4.7 Точки, джиттер (jitter), вайолинплот (violinplot), ящики с усами (boxplot), Вот другие способы показать распределение числовой переменной: iris %&gt;% ggplot(aes(Species, Petal.Length))+ geom_point() iris %&gt;% ggplot(aes(Species, Petal.Length))+ geom_jitter() iris %&gt;% ggplot(aes(Species, Petal.Length))+ geom_jitter(width = 0.3) library(&quot;ggbeeswarm&quot;) iris %&gt;% ggplot(aes(Species, Petal.Length))+ geom_quasirandom() diamonds %&gt;% ggplot(aes(cut, price))+ geom_violin() diamonds %&gt;% ggplot(aes(cut, price))+ geom_boxplot() 4.8 Фасетизация Достаточно мощным инструментом анализа данных является фасетизация, которая позволяет разбивать графики на основе какой-то переменной. diamonds %&gt;% ggplot(aes(carat, price))+ geom_point(size = 0.3)+ facet_wrap(~cut) При этом иногда так бывает, что наличие какой-то одного значение в одном из фасетов, заставляет иметь одну и ту же шкалу для всех остальных. Это можно изменить при помощи аргумента scales: diamonds %&gt;% ggplot(aes(carat, price))+ geom_point(size = 0.3)+ facet_wrap(~cut, scales = &quot;free&quot;) Кроме того, можно добавлять дополнительные аргументы: diamonds %&gt;% ggplot(aes(carat, price))+ geom_point(size = 0.3)+ facet_wrap(~cut+color) Кроме того, можно создавать сетки переменных используя geom_grid(), они facet_grid()ньше места, чем facet_wrap(): diamonds %&gt;% ggplot(aes(carat, price))+ geom_point(size = 0.3)+ facet_grid(cut~color, scales = &quot;free&quot;) Кроме того facet_grid() позволяет делать обощающие поля, где представлены все данные по какой-то строчке или столбцу: diamonds %&gt;% ggplot(aes(carat, price))+ geom_point(size = 0.3)+ facet_grid(cut~color, scales = &quot;free&quot;, margins = TRUE) "],
["references.html", "References", " References "]
]
