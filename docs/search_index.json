[
["intro.html", "2 Введение 2.1 Наука о данных 2.2 Не R единым 2.3 Основные этапы исследования 2.4 Введение в RStudio 2.5 R как калькулятор 2.6 Comments 2.7 Functions 2.8 Variables 2.9 Vector", " 2 Введение 2.1 Наука о данных Наука о данных — это новая область знаний, которая активно развивается в последнее время. Она находиться на пересечении компьютерных наук, статистики и математики, и трудно сказать, действительно ли это наука. При этом это движение развивается в самых разных научных направлениях, иногда даже оформляясь в отдельную отрасль: биоинформатика вычислительная криминалистика цифровые гуманитарные исследования датажурналистика … Все больше книг “Data Science for …”: psychologists (Hansjörg 2019) immunologists (Thomas and Pallett 2019) business (Provost and Fawcett 2013) public policy (Brooks and Cooper 2013) fraud detection (Baesens, Van Vlasselaer, and Verbeke 2015) … Среди умений датасаентистов можно перечислить следующие: сбор и обработка данных трансформация данных визуализация данных статистическое моделирование данных представление полученных результатов организация всей работы воспроизводимым способом 2.2 Не R единым R (R Core Team 2019) — это один из популярных языков для анализа данных. Однако у него вполне есть и альтернативы: Python (VanderPlas 2016; Grus 2019) Julia (Bezanson et al. 2017) bash (Janssens 2014) java (Brzustowicz 2017) … Кроме того ответы на любые проблемы можно найти в… R for data science (Wickham 2016), онлайн R community stackoverflow любой поисковик … 2.3 Основные этапы исследования формулировка гипотез(ы) выбор зависимой и независимых переменных сбор данных работа с данными, которую можно представить следующей схемой: При анализе данных бывают разные соблазны, с которыми нужно бороться: Cherry Picking — выбор только тех данных, которые удовлетворяют гипотезе. Data Dredging — проведение множества тестов, пока не появится статистически значимый результат. Систематическая ошибка выжившего — анализ только одной группы объектов (выжившим), так как данных по другой группе (погибшим) данных нет. Ложная корреляция — наличие высокой корреляции между переменными не гарантирует, что между ними есть причино-следственная связь. Неуравновешанная выборка — если выборка неуравновешена, она перестает представлять генеральную совокупность, что может исказить выводы. Чтобы проиллюстрировать этапы исследования давайте возьмем данные из опрос, который вы сейчас пройдете. 2.4 Введение в RStudio R is the programming language. RStudio is the most popular IDE (Integrated Development Environment) for R language. When you open RStudio for the first time you can see something like this: When you press button at the top of the left window you will be able to see all four panels of RStudio. 2.5 R как калькулятор Lets first start with the calculator. Press in R console 2+9 ## [1] 11 50*(9-20) ## [1] -550 3^3 ## [1] 27 9^0.5 ## [1] 3 9+0.5 ## [1] 9.5 9+.5 ## [1] 9.5 pi ## [1] 3.141593 Remainder after division 10 %% 3 ## [1] 1 So you are ready to solve some really hard equations (round it four decimal places): \\[\\frac{\\pi+2}{2^{3-\\pi}}\\] 2.6 Comments Any text after a hash # within the same line is considered a comment. 2+2 # it is four ## [1] 4 # you can put any comments here 3+3 ## [1] 6 2.7 Functions The most important part of R is functions: here are some of them: sqrt(4) ## [1] 2 abs(-5) ## [1] 5 sin(pi/2) ## [1] 1 cos(pi) ## [1] -1 sum(2, 3, 9) ## [1] 14 prod(5, 3, 9) ## [1] 135 sin(cos(pi)) ## [1] -0.841471 Each function has a name and zero or more arguments. All arguments of the function should be listed in parenthesis and separated by comma: pi ## [1] 3.141593 round(pi, 2) ## [1] 3.14 Each function’s argument has its own name and serial number. If you use names of the function’s arguments, you can put them in any order. If you do not use names of the function’s arguments, you should put them according the serial number. round(x = pi, digits = 2) ## [1] 3.14 round(digits = 2, x = pi) ## [1] 3.14 round(x = pi, d = 2) ## [1] 3.14 round(d = 2, x = pi) ## [1] 3.14 round(pi, 2) ## [1] 3.14 round(2, pi) # this is not the same as all previous! ## [1] 2 There are some functions without any arguments, but you still should use parenthesis: Sys.Date() # correct ## [1] &quot;2020-09-02&quot; Sys.Date # wrong ## function () ## as.Date(as.POSIXlt(Sys.time())) ## &lt;bytecode: 0x613d82800608&gt; ## &lt;environment: namespace:base&gt; Each function in R is documented. You can read its documentation typing a question mark before the function name: ?Sys.Date Explore the function log() and calculate the following logarithm: \\[\\log_3(3486784401)\\] 2.8 Variables Everything in R can be stored in a variable: x &lt;- 5 + 6 As a result, no output in the Console, and a new variable x appear in the Environment window. From now on I can use this new variable: x + x ## [1] 22 sum(x, x, 7) ## [1] 29 All those operations don’t change the variable value. In order to change the variable value you need to make a new assignment: x &lt;- 5 + 6 + 7 The fast way for creating &lt;- in RStudio is to press Alt - on your keyboard. It is possible to use equal sign = for assignment operation, but the recommendations are to use arrow &lt;- for the assignment, and equal sign = for giving arguments’ value inside the functions. For removing vector you need to use the function rm(): rm(x) x ## Error in eval(expr, envir, enclos): object &#39;x&#39; not found 2.8.1 Variable comparison It is possible to compare different variables x &lt;- 18 x &gt; 18 ## [1] FALSE x &gt;= 18 ## [1] TRUE x &lt; 100 ## [1] TRUE x &lt;= 18 ## [1] TRUE x == 18 ## [1] TRUE x != 18 ## [1] FALSE Operator ! can work by itself changing logical values into reverse: !TRUE ## [1] FALSE !FALSE ## [1] TRUE 2.8.2 Variable types There are several types of variables in R. In this course the only important types will be double (all numbers), character (or strings), and logical: x &lt;- 2+3 typeof(x) ## [1] &quot;double&quot; y &lt;- &quot;Cześć&quot; typeof(y) ## [1] &quot;character&quot; z &lt;- TRUE typeof(z) ## [1] &quot;logical&quot; 2.9 Vector An R object that contains multiple values of the same type is called vector. It could be created with the command c(): c(3, 0, pi, 23.4, -53) ## [1] 3.000000 0.000000 3.141593 23.400000 -53.000000 c(&quot;Kraków&quot;, &quot;Warszawa&quot;, &quot;Cieszyn&quot;) ## [1] &quot;Kraków&quot; &quot;Warszawa&quot; &quot;Cieszyn&quot; c(FALSE, FALSE, TRUE) ## [1] FALSE FALSE TRUE a &lt;- c(2, 3, 4) b &lt;- c(5, 6, 7) c(a, b) ## [1] 2 3 4 5 6 7 For the number sequences there is an easy way: 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 3:-5 ## [1] 3 2 1 0 -1 -2 -3 -4 -5 From now on you can understand that everything we have seen before is a vector of length one. That is why there is [1] in all outputs: it is just an index of elements in a vector. Have a look here: 1:60 ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ## [26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 ## [51] 51 52 53 54 55 56 57 58 59 60 60:1 ## [1] 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 ## [26] 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 ## [51] 10 9 8 7 6 5 4 3 2 1 There is also a function seq() for creation of arithmetic progressions: 1:20 ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 seq(from = 1, to = 20, by = 1) ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 seq(from = 2, to = 100, by = 13) ## [1] 2 15 28 41 54 67 80 93 Use the argument length.out of function seq() and create an arithmetic sequence from \\(\\pi\\) to \\(2\\pi\\) of length 50. There are also some built-in vectors: letters ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; ## [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; LETTERS ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; ## [20] &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; month.name ## [1] &quot;January&quot; &quot;February&quot; &quot;March&quot; &quot;April&quot; &quot;May&quot; &quot;June&quot; ## [7] &quot;July&quot; &quot;August&quot; &quot;September&quot; &quot;October&quot; &quot;November&quot; &quot;December&quot; month.abb ## [1] &quot;Jan&quot; &quot;Feb&quot; &quot;Mar&quot; &quot;Apr&quot; &quot;May&quot; &quot;Jun&quot; &quot;Jul&quot; &quot;Aug&quot; &quot;Sep&quot; &quot;Oct&quot; &quot;Nov&quot; &quot;Dec&quot; 2.9.1 Vector coercion Vectors are R objects that contain multiple values of the same type. But what if we merged together different types? c(1, &quot;34&quot;) ## [1] &quot;1&quot; &quot;34&quot; c(1, TRUE) ## [1] 1 1 c(TRUE, &quot;34&quot;) ## [1] &quot;TRUE&quot; &quot;34&quot; It is clear that there is a hierarchy: strings &gt; double &gt; logical. It is not universal across different programming languages. It doesn’t correspond to the amount of values of particular type: c(1, 2, 3, &quot;34&quot;) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;34&quot; c(1, TRUE, FALSE, FALSE) ## [1] 1 1 0 0 The same story could happen during other operations: 5+TRUE ## [1] 6 2.9.2 Vector operations All operations, that we discussed earlier, could be done with vectors of the same length: 1:5 + 6:10 ## [1] 7 9 11 13 15 1:5 - 6:10 ## [1] -5 -5 -5 -5 -5 1:5 * 6:10 ## [1] 6 14 24 36 50 There are operations where the vector of any length and vector of length one is involved: 1:5 + 7 ## [1] 8 9 10 11 12 1:5 - 7 ## [1] -6 -5 -4 -3 -2 1:5 / 7 ## [1] 0.1428571 0.2857143 0.4285714 0.5714286 0.7142857 There are a lot of functions in R that are vectorised. That means that applying this function to a vector is the same as applying this function to each element of the vector: sin(1:5) ## [1] 0.8414710 0.9092974 0.1411200 -0.7568025 -0.9589243 sqrt(1:5) ## [1] 1.000000 1.414214 1.732051 2.000000 2.236068 abs(-5:3) ## [1] 5 4 3 2 1 0 1 2 3 2.9.3 Indexing vectors How to get some value or banch of values from a vector? You need to index them: x &lt;- c(3, 0, pi, 23.4, -53) y &lt;- c(&quot;Kraków&quot;, &quot;Warszawa&quot;, &quot;Cieszyn&quot;) x[4] ## [1] 23.4 y[2] ## [1] &quot;Warszawa&quot; It is possible to have a vector as index: x[1:2] ## [1] 3 0 y[c(1, 3)] ## [1] &quot;Kraków&quot; &quot;Cieszyn&quot; It is possible to index something that you do not want to see in the result: y[-2] ## [1] &quot;Kraków&quot; &quot;Cieszyn&quot; x[-c(1, 4)] ## [1] 0.000000 3.141593 -53.000000 It is possible to have other variables as an index z &lt;- c(3, 2) x[z] ## [1] 3.141593 0.000000 y[z] ## [1] &quot;Cieszyn&quot; &quot;Warszawa&quot; It is possible to index with a logical vector: x[c(TRUE, FALSE, TRUE, TRUE, FALSE)] ## [1] 3.000000 3.141593 23.400000 That means that we could use TRUE/FALSE-vector produced by comparison: x[x &gt; 2] ## [1] 3.000000 3.141593 23.400000 It works because x &gt; 2 is a vector of logical values: x &gt; 2 ## [1] TRUE FALSE TRUE TRUE FALSE It is possible to use ! operator here changing all TRUE values to FALSE and vice versa. x[!(x &gt; 2)] ## [1] 0 -53 How many elements in the vector g if expression g[pi &lt; 1000] does not return an error? 2.9.4 NA Sometimes there are some missing values in the data, so it is represented with NA NA ## [1] NA c(1, NA, 9) ## [1] 1 NA 9 c(&quot;Kraków&quot;, NA, &quot;Cieszyn&quot;) ## [1] &quot;Kraków&quot; NA &quot;Cieszyn&quot; c(TRUE, FALSE, NA) ## [1] TRUE FALSE NA It is possible to check, whether there are missing values or not x &lt;- c(&quot;Kraków&quot;, NA, &quot;Cieszyn&quot;) y &lt;- c(&quot;Kraków&quot;, &quot;Warszawa&quot;, &quot;Cieszyn&quot;) is.na(x) ## [1] FALSE TRUE FALSE is.na(y) ## [1] FALSE FALSE FALSE Some functions doesn’t work with vecotors that contain missed values, so you need to add argument na.rm = TRUE: x &lt;- c(1, NA, 9, 5) mean(x) ## [1] NA mean(x, na.rm = TRUE) ## [1] 5 min(x, na.rm = TRUE) ## [1] 1 max(x, na.rm = TRUE) ## [1] 9 median(x, na.rm = TRUE) ## [1] 5 range(x, na.rm = TRUE) ## [1] 1 9 References "]
]
