[
["трансформация-данных-с-dplyr-и-tidyr.html", "3 Трансформация данных с dplyr и tidyr 3.1 Данные 3.2 dplyr 3.3 Объединение датафреймов 3.4 Пакет tidyr", " 3 Трансформация данных с dplyr и tidyr Загрузим библиотеку: library(tidyverse) 3.1 Данные 3.1.1 Датасет с опечатками Этот датасет получен после обработки данных из статьи The Gyllenhaal Experiment Расселла Голденберга и Мэта Даниэлса для pudding. Они анализировали опечатки, которые делают пользователи, когда ищут информацию про знаменитостей. misspellings &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/2020_HSE_ds4l_NN/master/data/misspelling_dataset.csv&quot;) ## Parsed with column specification: ## cols( ## correct = col_character(), ## spelling = col_character(), ## count = col_double() ## ) misspellings В датасете следующие колонки: correct — правильное написание spelling — написание пользователей count — количество написаний (из колонки spelling) в датасете 3.1.2 diamonds diamonds — это датасет встроенный в пакет tidyverse. diamonds ?diamonds 3.2 dplyr Здесь и здесь находятся щпаргалки про dplyr. 3.2.1 filter() Эта функция фильтрует строчки согласно некоторому условию. Какие произнесения были использованы меньше чем 10 ползователями? misspellings %&gt;% filter(count &lt; 10) %&gt;% — это конвеера (по-русски, еще называют пайпом или шуточно велосипедом). Горячая клавиши для вызова конвеера Ctrl Shift M. Конвеер позволяет создавать цепочки операций, так что результат работы одной функции становится инпутом для работы следующей функции. Сравните: sort(sqrt(abs(sin(1:22))), decreasing = TRUE) ## [1] 0.9999951 0.9952926 0.9946649 0.9805088 0.9792468 0.9554817 0.9535709 ## [8] 0.9173173 0.9146888 0.8699440 0.8665952 0.8105471 0.8064043 0.7375779 ## [15] 0.7325114 0.6482029 0.6419646 0.5365662 0.5285977 0.3871398 0.3756594 ## [22] 0.0940814 1:22 %&gt;% sin() %&gt;% abs() %&gt;% sqrt() %&gt;% sort(decreasing = TRUE) ## [1] 0.9999951 0.9952926 0.9946649 0.9805088 0.9792468 0.9554817 0.9535709 ## [8] 0.9173173 0.9146888 0.8699440 0.8665952 0.8105471 0.8064043 0.7375779 ## [15] 0.7325114 0.6482029 0.6419646 0.5365662 0.5285977 0.3871398 0.3756594 ## [22] 0.0940814 Конвееры широко используются внутри tidyverse и могут не всегда работать вне пакетов экосистемы: Так что функция filter() вовзращает строчки, подходящие некоторому условию: misspellings %&gt;% filter(count &lt; 10) Можно использовать несколько условий. Какие произнесения Deschanel было использовано меньше чем 10 ползователями? misspellings %&gt;% filter(count &lt; 10, correct == &quot;deschanel&quot;) Кроме того в этой функции можно использовать условие с ИЛИ. Какие произнесения были использовано меньше чем 10 ИЛИ более чем 500 пользователями? misspellings %&gt;% filter(count &lt; 10 | count &gt; 500) 3.2.2 slice() Эта функция фильтрует строчки на основе их индекса. misspellings %&gt;% slice(3:7) 3.2.3 select() Эта функция выбирает переменные в датафрейме на основе их имени или индекса. diamonds %&gt;% select(8:10) diamonds %&gt;% select(color:price) diamonds %&gt;% select(-carat) diamonds %&gt;% select(-c(carat, cut, x, y, z)) diamonds %&gt;% select(cut, depth, price) 3.2.4 arrange() Эта функция сортирует строчки в датафрейме (числа — по возрастанию/убыванию, строки — по алфавиту). misspellings %&gt;% arrange(count) diamonds %&gt;% arrange(desc(carat), price) diamonds %&gt;% arrange(-carat, price) 3.2.5 distinct() Эта функция возвращает уникальные строчки из датафрейма. misspellings %&gt;% distinct(correct) misspellings %&gt;% distinct(spelling) diamonds %&gt;% distinct(color, cut) Отфильтруйте во встроенном датасете starwars героев, которые выше 180, имеют массу меньше 80. Сколько уникальных планет происхождения этих героев (переменная homeworld)? 3.2.6 mutate() Эта функция создает новые переменные. misspellings %&gt;% mutate(misspelling_length = nchar(spelling), id = 1:n()) Создайте переменную с индексом массы тела: \\(\\frac{mass}{height^2}\\) для всех героев из датасета starwars. Сколько героев страдают ожирением(имеют индекс массы тела больше 30)? (Не забудьте перевести высоту из сантиметров в метры). 3.2.7 group_by(...) %&gt;% summarise(...) Эти функции позволяют сгруппировать переменные по какой-то переменной в одном из столбцов датафрейма и получить какое обобщение (например, максимум, минимум, последнее значение, среднее, медиану и др.) misspellings %&gt;% summarise(min(count), mean(count)) misspellings %&gt;% group_by(correct) %&gt;% summarise(mean(count)) ## `summarise()` ungrouping output (override with `.groups` argument) misspellings %&gt;% group_by(correct) %&gt;% summarise(my_mean = mean(count)) ## `summarise()` ungrouping output (override with `.groups` argument) Если нужно посчитать количество наблюдений в группе, используйте функцию n() внутри summarise() или функцию count(): misspellings %&gt;% group_by(correct) %&gt;% summarise(n = n()) ## `summarise()` ungrouping output (override with `.groups` argument) misspellings %&gt;% count(correct) Результат можно отсортировать, используя аргумент sort: misspellings %&gt;% count(correct, sort = TRUE) Бывают случаи, когда не хочется иметь отдельное саммари, а хочется добавить полученную информацию в новую колонку, для этого можно вместо summarise() использовать mutate() misspellings %&gt;% group_by(correct) %&gt;% mutate(my_mean = mean(count)) Вот схема: В датасете starwars создайте переменную, содержащую среднее значение роста (height) для каждого вида (species). 3.3 Объединение датафреймов 3.3.1 bind_... Это семейство фукнций, который позволяет объединять датасеты: my_tbl &lt;- tibble(a = c(1, 5, 2), b = c(&quot;e&quot;, &quot;g&quot;, &quot;s&quot;)) Здесь датасеты объеденены по строчкам: my_tbl %&gt;% bind_rows(my_tbl) Если какой-то из колонок не хватает, то нехватающие значения будут заполнены NA: my_tbl %&gt;% bind_rows(my_tbl[,-1]) Вот так можно соединить датафреймы по колонкам: my_tbl %&gt;% bind_cols(my_tbl) ## New names: ## * a -&gt; a...1 ## * b -&gt; b...2 ## * a -&gt; a...3 ## * b -&gt; b...4 Если количество строчек будет разным функция вернет ошибку: my_tbl %&gt;% bind_cols(my_tbl[-1,]) ## Error: Can&#39;t recycle `..1` (size 3) to match `..2` (size 2). 3.3.2 .._join() Данное семейство функций позволяет объединять датафреймы на основании некоторой общей колонки или набора общих колонок. languages &lt;- tibble( languages = c(&quot;Selkup&quot;, &quot;French&quot;, &quot;Chukchi&quot;, &quot;Polish&quot;), countries = c(&quot;Russia&quot;, &quot;France&quot;, &quot;Russia&quot;, &quot;Poland&quot;), iso = c(&quot;sel&quot;, &quot;fra&quot;, &quot;ckt&quot;, &quot;pol&quot;) ) languages country_population &lt;- tibble( countries = c(&quot;Russia&quot;, &quot;Poland&quot;, &quot;Finland&quot;), population_mln = c(143, 38, 5)) country_population inner_join(languages, country_population) ## Joining, by = &quot;countries&quot; left_join(languages, country_population) ## Joining, by = &quot;countries&quot; right_join(languages, country_population) ## Joining, by = &quot;countries&quot; anti_join(languages, country_population) ## Joining, by = &quot;countries&quot; anti_join(country_population, languages) ## Joining, by = &quot;countries&quot; full_join(country_population, languages) ## Joining, by = &quot;countries&quot; 3.4 Пакет tidyr Перед нами датасет с количеством носителей некоторых языков Индии according the census 2001 (data from Wikipedia): langs_in_india_short &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/2020.02_Naumburg_R/master/data/languages_in_india.csv&quot;) ## Parsed with column specification: ## cols( ## language = col_character(), ## n_L1_sp = col_double(), ## n_L2_sp = col_double(), ## n_L3_sp = col_double(), ## n_all_sp = col_double() ## ) Широкий формат langs_in_india_short Длинный формат Широкий формат → длинный формат: tidyr::pivot_longer() langs_in_india_short %&gt;% pivot_longer(names_to = &quot;type&quot;, values_to = &quot;n_speakers&quot;, n_L1_sp:n_all_sp)-&gt; langs_in_india_long langs_in_india_long Длинный формат → шиирокий формат: tidyr::pivot_wider() langs_in_india_long %&gt;% pivot_wider(names_from = &quot;type&quot;, values_from = &quot;n_speakers&quot;)-&gt; langs_in_india_short langs_in_india_short 3.4.1 Концепция tidy data Одни и те же данные можно представить разными способами. Основная философия tidyverse построена вокруг понятия tidy data: Каждая переменная содержится в отдельном столбце. Каждое наблюдение содержится в отдельной строчке. Каждое значение записано в свою ячейку. Здесь находятся данные содержащие информацию о деревнях в Дагестане в формате .xlsx. Данные разделены на разные листы и содержат разные переменные (данные полученные из разных источников, так что у них переменных есть префикс _s1 – первый источник; и _s2 – второй источник): id_s1 – (s1) id из первого источника; name_1885 – (s1) название деревни по переписи 1885 census_1885 – (s1) количество людей по переписи 1885 name_1895 – (s1) название деревни по переписи 1895 census_1895 – (s1) количество людей по переписи 1895 name_1926 – (s1) название деревни по переписи 1926 census_1926 – (s1) количество людей по переписи 1926 name_2010 – (s1) название деревни по переписи 2010 census_2010 – (s1) количество людей по переписи2010 language_s1 – (s1) язык, на котором говорят в деревне согласно первому источнику name_s2 – (s2) название деревни согласно второму источнику language_s2 – (s2) язык, на котором говорят в деревне согласно второму источнику Lat – (s2) широта Lon – (s2) долгота elevation – (s2) высота Соедините все эти разные таблицы из .xlsx: Посчитайте сколько раз языки совпадают в двух источниках (переменные language_s1 и language_s2). Посчитайте среднюю высоту для языков из первого источника, какой выше? Посчитайте количество носителей разных языков (согласно второму источнику) для каждой переписи. Покажите значение для лакского языка: "]
]
