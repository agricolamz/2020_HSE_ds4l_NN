---
output: html_document
editor_options: 
  chunk_output_type: console
---
# Введение {#intro}

## Наука о данных
Наука о данных --- это новая область знаний, которая активно развивается в последнее время. Она находиться на пересечении компьютерных наук, статистики и математики, и трудно сказать, действительно ли это наука. При этом это движение развивается в самых разных научных направлениях, иногда даже оформляясь в отдельную отрасль:

* биоинформатика
* вычислительная криминалистика
* цифровые гуманитарные исследования
* датажурналистика
* ...

Все больше книг "Data Science for ...":

* psychologists [@hansjoerg19]
* immunologists [@thomas19]
* business [@provost13]
* public policy [@brooks13]
* fraud detection [@baesens15]
* ...

Среди умений датасаентистов можно перечислить следующие:

* сбор и обработка данных
* трансформация данных
* визуализация данных
* статистическое моделирование данных
* представление полученных результатов
* организация всей работы **воспроизводимым способом**

## Не R единым

R [@r19] --- это один из популярных языков для анализа данных. Однако у него вполне есть и альтернативы:

* Python [@vanderplas16; @grus19]
* Julia [@bezanson17]
* bash [@janssens14]
* java [@brzustowicz17]
* ...

Кроме того ответы на любые проблемы можно найти в...

* R for data science [@wickham16], [онлайн](https://r4ds.had.co.nz/)
* [R community](https://community.rstudio.com/)
* [stackoverflow](https://stackoverflow.com)
* [рускоязычный телеграм-канал](https://t.me/rlang_ru) (но там есть правила по задаванию вопросов)
* [телеграм-канал, где собираются все новости по R](https://t.me/rlang_feed)
* любой поисковик
* ...

## Основные этапы исследования

* формулировка гипотез(ы)
* выбор зависимой и независимых переменных
* сбор данных
* работа с данными, которую можно представить следующей схемой:
```{r, echo = FALSE}
DiagrammeR::grViz("digraph {

graph [compound = true, fillcolor = red, layout = dot]
node [shape = rectangle]

импорт; трансформация; визуализация; моделирование; представление

subgraph cluster0 {
  трансформация -> визуализация -> моделирование -> трансформация
  }

импорт -> трансформация [lhead = cluster0]
моделирование -> представление  [ltail = cluster0]

}")
```

При анализе данных бывают разные соблазны, с которыми нужно бороться:

* **Cherry Picking** --- выбор только тех данных, которые удовлетворяют гипотезе.
* **Data Dredging** --- проведение множества тестов, пока не появится статистически значимый результат.
* **Систематическая ошибка выжившего** --- анализ только одной группы объектов (выжившим), так как данных по другой группе (погибшим) данных нет.
* **Ложная корреляция** --- наличие высокой корреляции между переменными не гарантирует, что между ними есть причино-следственная связь.
* **Неуравновешанная выборка** --- если выборка неуравновешена, она перестает представлять генеральную совокупность, что может исказить выводы.

Чтобы проиллюстрировать этапы исследования давайте возьмем данные из [опрос](https://docs.google.com/forms/d/e/1FAIpQLSdJWr27JJGi0xSoBZV-xEmwLwlclpdLDtkU5mWUncMv7O6vAg/viewform), который вы сейчас пройдете.


## Введение в RStudio
R --- это язык программироваия. RStudio --- наиболее популярный IDE (Integrated Development Environment) для R.

Когда вы откроете RStudio первый раз, то увидеть что-то такое:

![](images/01.01.rstudio.png)

Если нажать наверху на кнопку ![](images/01.02.rstudio_button.png), то можно будет увидеть все четыре окна:

![](images/01.03.rstudio.png)

## R как калькулятор

```{r}
2+9
50*(9-20)
3^3
9^0.5
9+0.5
9+.5
pi
```

Остаток от деления:

```{r}
10 %% 3
```

```{block, type = "rmdtask"}
Теперь вы готовы решит ваше первое выражение (результат округлите до 3 знаков после запятой):
```


$$\frac{\pi+2}{2^{3-\pi}}$$

```{r, results='asis', echo = FALSE, eval = knitr::is_html_output()}
checkdown::check_question(answer =  round((pi+2)/(2^(3-pi)), 3))
```

## Комментарии

Любой текст после знака `#` на той же строчке не исполняется

```{r}
2+2 # это четыре

# можно сюда написать комментарий
3+3
```


## Функции

Самая важная часть R --- функции. Вот некоторые из них:

```{r}
sqrt(4)
abs(-5)
sin(pi/2)
cos(pi)
sum(2, 3, 9)
prod(5, 3, 9)
sin(cos(pi))
```

У каждой функции есть имя и аргументы (от нуля и вверх). Все аргументы перечисляются в круглых скобках, и разделены запятой:

```{r}
round(pi, 2)
```

Каждый аргумент функции имеет имя и порядковый номер. Если вы используете аргументы функции, вы можете помещать их в любом порядке. Если имена аргументов функции не названы, то их следует перечислять в соответствии с порядковым номером.

```{r}
round(x = pi, digits = 2)
round(digits = 2, x = pi)
round(x = pi, d = 2)
round(d = 2, x = pi)
round(pi, 2)
round(2, pi) # это не то же самое, что на предыдущих строчках!
```

Существуют функции без аргументов, но с ними все равно нужно использовать скобки:

```{r}
Sys.Date() # correct
Sys.Date # wrong
```

Все функции в R имеют документацию. Ее можно увидеть, если поставить вопросительный знак перед именем функции:

```{r, eval = FALSE}
?Sys.Date
```

```{block, type = "rmdtask"}
Исследуйте следующую функцию `log()` и посчитайте следующий логарифм:
```

$$\log_3(3486784401)$$

```{r, results='asis', echo = FALSE, eval = knitr::is_html_output()}
checkdown::check_question(answer = log(3486784401, base = 3))
```

## Переменные

Все в R можно хранить в переменной:

```{r}
x <- 5 + 6
```

![](images/01.04.variable.png)

В результате работы предыдущей команды, нет никокого результата в консоли, однако новая переменная *x* окне окружения. Теперь можно использовать эту новую переменную:

```{r}
x + x
sum(x, x, 7)
```

Все эти операции не изменяют значения переменной *x*. Чтобы изменить значения, нужно сделать новое приписывание:

```{r}
x <- 5 + 6 + 7
```

Существуют горячие клавиши для создания `<-` в RStudio: `Alt -`.

Для приписывания значения можно использовать и знак `=`, однако рекомендуется все же использовать `<-` для приписывания и знак `=` для перечисления аргументов функции.

Чтобы удалить переменную можно использовать функцию `rm()`:

```{r error = TRUE}
rm(x)
x
```

Переменные бывают разного типа, вот основные:

```{r}
typeof(4.3) # числа
typeof("тро-ло-ло") # строки
typeof(TRUE) # логические
```


### Сравнение переменных

Переменные можно сравнивать:

```{r}
x <- 18
x > 18
x >= 18
x < 100
x <= 18
x == 18
x != 18
```

Оператор `!` изменяет логические значения на противоположные:

```{r}
!TRUE
!FALSE
!(x > 18)
```

Стоит помнить о логических операциях, которые позволяют соединять разные логические выражения:

```{r}
x <- 5
x > 2 & x < 2 # логическое и
x > 10 & x < 100 # логическое и
x > 2 | x < 4 # логическое или
x > 6 | x < 4 # логическое или
```

## Вектор

Объект в R, который содержит элементы одного типа, называется **вектор**. Вектор можно создать при помощи функции `c()`:

```{r}
c(3, 0, pi, 23.4, -53)
c("Нижний Новгород", "Пермь", "Санкт Петербург")
c(FALSE, FALSE, TRUE)

a <- c(2, 3, 4)
b <- c(5, 6, 7)
c(a, b)
```

Для последовательностей чисел есть и другой способ:

```{r}
1:10
3:-5
```

Теперь становится понятно, что все, что мы видели раньше было вектором длины один. Вот почему там все время было `[1]`: Это индекс элементов в R. Посмотрите:

```{r}
1:60
60:1
```

На этом месте также должно стать очевидно, что в отличие от кучи языков программирования R считает с 1, а не с 0.

Для того чтобы создавать арифметические прогресии существует функция `seq()`:

```{r}
1:20
seq(from = 1, to = 20, by = 1)
seq(from = 2, to = 100, by = 13)
```

```{block, type = "rmdtask"}
Используйте аргумент `length.out` функции `seq()`, чтобы создать арифметическую прогрессию от $\pi$ до $2\pi$ длины 50.

```

```{r, include=FALSE}
seq(pi, 2*pi, length.out = 50)
```

Кроме того в R есть какое-то количество встроенных векторов:

```{r}
letters
LETTERS
month.name
month.abb
```

### Приведение типов
По определению вектор может содержать только единицы **одного типа**. Но что происходит, если соединить элементы разных типов?

```{r}
c(1, "34")
c(1, TRUE)
c(TRUE, "34")
```

Мы видим иерархию: строки > числа > логические выражения. Это не универсально между разными языками программирования. Также это не зависит от количество элементов того или иного типа:

```{r}
c(1, 2, 3, "34")
c(1, TRUE, FALSE, FALSE)
```

Приведение типов может случится, во время выполнения и других операций:

```{r}
5+TRUE
```

### Операции с векторами и векторизованные операции

Все операции, которые мы раньше обсуждали, можно сделать с векторами одинаковой длины:

```{r}
1:5 + 6:10
1:5 - 6:10
1:5 * 6:10
```

Если один из векторов имеет длинну один, то получится так называемая **векторизованная операция** --- операция произойдет с каждым элементом вектора:

```{r}
1:5 + 7
1:5 - 7
1:5 / 7
```

В R очень много **векторизованных** функций:

```{r}
sin(1:5)
sqrt(1:5)
abs(-5:3)
```

### Индексирование вектора

Как получить какое-то значение или несколько значений из вектора? Нужно использовать индекс:

```{r}
x <- c(3, 0, pi, 23.4, -53)
y <- c("Нижний Новгород", "Пермь", "Санкт Петербург")

x[4]
y[2]
```

Вектор можно использовать в качестве индекса:

```{r}
x[1:2]
y[c(1, 3)]
```

Отрицательный индекс исключает элементы из вектора:
```{r}
y[-2]
x[-c(1, 4)]
```

Разумеется, в качестве индекса можно использовать переменные:

```{r}
z <- c(3, 2)
x[z]
y[z]
```

Кроме того, в качесвте индекса можно использовать вектор логических значений:

```{r}
x[c(TRUE, FALSE, TRUE, TRUE, FALSE)]
```

А это в свою очередь означает, что в качестве индекса можно использовать вектор `TRUE/FALSE`, получающийся в результате сранвения:

```{r}
x[x > 2]
```

Это работает потому что выражение `x > 2` вектор логических значений:

```{r}
x > 2
```

Как мы обсуждали раньше оператор `!` может перевернуть все логические значения на противоположные:

```{r}
x[!(x > 2)]
```

```{block, type = "rmdtask"}
Сколько элементов в векторе `g`, если выражение `g[pi < 1000]` не возвращает ошибки?
```

```{block, type = "rmdtask"}
Во встроенном датасете `Nile` содержаться данные о ежегодном разливе Нила в 1871--1970 годах (в миллиардах кубических метров). Сколько в датасете наблюдений больше 1000 и меньше 1200.
```

```{r, results='asis', echo = FALSE, eval = knitr::is_html_output()}
checkdown::check_question(answer = length(Nile[Nile > 1000 & Nile < 1200]))
```


### Пропущенные значения

Иногда в процессе сбора данных возникают пропущенные значения. Для представления таких данных в R используется последовательность `NA`:

```{r}
NA
c(1, NA, 9)
c("Нижний Новгород", NA, "Санкт Петербург")
c(TRUE, FALSE, NA)
```

Функция `is.na` проверяет, есть ли в векторе пропущенные значения:

```{r}
x <- c("Нижний Новгород", NA, "Санкт Петербург")
y <- c("Нижний Новгород", "Пермь", "Санкт Петербург")
is.na(x)
is.na(y)
```

Некоторые функции не работают с векторами, которые содержат пропущенные значения, и имеют аргумент для их удаления `na.rm = TRUE`:

```{r}
x <- c(1, NA, 9, 5)
mean(x)
mean(x, na.rm = TRUE)
min(x, na.rm = TRUE)
max(x, na.rm = TRUE)
median(x, na.rm = TRUE)
range(x, na.rm = TRUE)
```

```{block, type = "rmdtask"}
Сколько элементов в векторе `g`, если выражение `g[pi < 1000]` не возвращает ошибки?
```

