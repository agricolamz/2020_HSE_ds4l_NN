---
output: html_document
editor_options: 
  chunk_output_type: console
---
# Введение {#intro}

## Наука о данных
Наука о данных --- это новая область знаний, которая активно развивается в последнее время. Она находиться на пересечении компьютерных наук, статистики и математики, и трудно сказать, действительно ли это наука. При этом это движение развивается в самых разных научных направлениях, иногда даже оформляясь в отдельную отрасль:

* биоинформатика
* вычислительная криминалистика
* цифровые гуманитарные исследования
* датажурналистика
* ...

Все больше книг "Data Science for ...":

* psychologists [@hansjoerg19]
* immunologists [@thomas19]
* business [@provost13]
* public policy [@brooks13]
* fraud detection [@baesens15]
* ...

Среди умений датасаентистов можно перечислить следующие:

* сбор и обработка данных
* трансформация данных
* визуализация данных
* статистическое моделирование данных
* представление полученных результатов
* организация всей работы **воспроизводимым способом**

## Не R единым

R [@r19] --- это один из популярных языков для анализа данных. Однако у него вполне есть и альтернативы:

* Python [@vanderplas16; @grus19]
* Julia [@bezanson17]
* bash [@janssens14]
* java [@brzustowicz17]
* ...

Кроме того ответы на любые проблемы можно найти в...

* R for data science [@wickham16], [онлайн](https://r4ds.had.co.nz/)
* [R community](https://community.rstudio.com/)
* [stackoverflow](https://stackoverflow.com)
* [рускоязычный телеграм-канал](https://t.me/rlang_ru) (но там есть правила по задаванию вопросов)
* [телеграм-канал, где собираются все новости по R](https://t.me/rlang_feed)
* любой поисковик
* ...

## Основные этапы исследования

* формулировка гипотез(ы)
* выбор зависимой и независимых переменных
* сбор данных
* работа с данными, которую можно представить следующей схемой:
```{r, echo = FALSE}
DiagrammeR::grViz("digraph {

graph [compound = true, fillcolor = red, layout = dot]
node [shape = rectangle]

импорт; трансформация; визуализация; моделирование; представление

subgraph cluster0 {
  трансформация -> визуализация -> моделирование -> трансформация
  }

импорт -> трансформация [lhead = cluster0]
моделирование -> представление  [ltail = cluster0]

}")
```

При анализе данных бывают разные соблазны, с которыми нужно бороться:

* **Cherry Picking** --- выбор только тех данных, которые удовлетворяют гипотезе.
* **Data Dredging** --- проведение множества тестов, пока не появится статистически значимый результат.
* **Систематическая ошибка выжившего** --- анализ только одной группы объектов (выжившим), так как данных по другой группе (погибшим) данных нет.
* **Ложная корреляция** --- наличие высокой корреляции между переменными не гарантирует, что между ними есть причино-следственная связь.
* **Неуравновешанная выборка** --- если выборка неуравновешена, она перестает представлять генеральную совокупность, что может исказить выводы.

Чтобы проиллюстрировать этапы исследования давайте возьмем данные из [опрос](https://docs.google.com/forms/d/e/1FAIpQLSdJWr27JJGi0xSoBZV-xEmwLwlclpdLDtkU5mWUncMv7O6vAg/viewform), который вы сейчас пройдете.


## Введение в RStudio
R --- это язык программироваия. RStudio --- наиболее популярный IDE (Integrated Development Environment) для R.

Когда вы откроете RStudio первый раз, то увидеть что-то такое:

![](images/01.01.rstudio.png)

Если нажать наверху на кнопку ![](images/01.02.rstudio_button.png), то можно будет увидеть все четыре окна:

![](images/01.03.rstudio.png)

## R как калькулятор

```{r}
2+9
50*(9-20)
3^3
9^0.5
9+0.5
9+.5
pi
```

Остаток от деления:

```{r}
10 %% 3
```

```{block, type = "rmdtask"}
Теперь вы готовы решит ваше первое выражение (результат округлите до 3 знаков после запятой):
```


$$\frac{\pi+2}{2^{3-\pi}}$$

```{r, results='asis', echo = FALSE}
checkdown::check_question(answer =  round((pi+2)/(2^(3-pi)), 3))
```

## Комментарии

Любой текст после знака `#` на той же строчке не исполняется

```{r}
2+2 # это четыре

# можно сюда написать комментарий
3+3
```


## Функции

Самая важная часть R --- функции. Вот некоторые из них:

```{r}
sqrt(4)
abs(-5)
sin(pi/2)
cos(pi)
sum(2, 3, 9)
prod(5, 3, 9)
sin(cos(pi))
```

У каждой функции есть имя и аргументы (от нуля и вверх). Все аргументы перечисляются в круглых скобках, и разделены запятой:

```{r}
round(pi, 2)
```

Каждый аргумент функции имеет имя и порядковый номер. Если вы используете аргументы функции, вы можете помещать их в любом порядке. Если имена аргументов функции не названы, то их следует перечислять в соответствии с порядковым номером.

```{r}
round(x = pi, digits = 2)
round(digits = 2, x = pi)
round(x = pi, d = 2)
round(d = 2, x = pi)
round(pi, 2)
round(2, pi) # это не то же самое, что на предыдущих строчках!
```

Существуют функции без аргументов, но с ними все равно нужно использовать скобки:

```{r}
Sys.Date() # correct
Sys.Date # wrong
```

Все функции в R имеют документацию. Ее можно увидеть, если поставить вопросительный знак перед именем функции:

```{r, eval = FALSE}
?Sys.Date
```

```{block, type = "rmdtask"}
Исследуйте следующую функцию `log()` и посчитайте следующий логарифм:
```

$$\log_3(3486784401)$$

```{r, results='asis', echo = FALSE}
checkdown::check_question(answer = log(3486784401, base = 3))
```

## Переменные

Все в R можно хранить в переменной:

```{r}
x <- 5 + 6
```

![](images/01.04.variable.png)

В результате работы предыдущей команды, нет никокого результата в консоли, однако новая переменная *x* окне окружения. Теперь можно использовать эту новую переменную:

```{r}
x + x
sum(x, x, 7)
```

Все эти операции не изменяют значения переменной *x*. Чтобы изменить значения, нужно сделать новое приписывание:

```{r}
x <- 5 + 6 + 7
```

Существуют горячие клавиши для создания `<-` в RStudio: `Alt -`.

Для приписывания значения можно использовать и знак `=`, однако рекомендуется все же использовать `<-` для приписывания и знак `=` для перечисления аргументов функции.

Чтобы удалить переменную можно использовать функцию `rm()`:

```{r error = TRUE}
rm(x)
x
```

Переменные бывают разного типа, вот основные:

```{r}
typeof(4.3) # числа
typeof("тро-ло-ло") # строки
typeof(TRUE) # логические
```


### Сравнение переменных

Переменные можно сравнивать:

```{r}
x <- 18
x > 18
x >= 18
x < 100
x <= 18
x == 18
x != 18
```

Оператор `!` изменяет логические значения на противоположные:

```{r}
!TRUE
!FALSE
!(x > 18)
```

Стоит помнить о логических операциях, которые позволяют соединять разные логические выражения:

```{r}
x <- 5
x > 2 & x < 2 # логическое и
x > 10 & x < 100 # логическое и
x > 2 | x < 4 # логическое или
x > 6 | x < 4 # логическое или
```

## Вектор

Объект в R, который содержит элементы одного типа, называется **вектор**. Вектор можно создать при помощи функции `c()`:

```{r}
c(3, 0, pi, 23.4, -53)
c("Нижний Новгород", "Пермь", "Санкт Петербург")
c(FALSE, FALSE, TRUE)

a <- c(2, 3, 4)
b <- c(5, 6, 7)
c(a, b)
```

Для последовательностей чисел есть и другой способ:

```{r}
1:10
3:-5
```

Теперь становится понятно, что все, что мы видели раньше было вектором длины один. Вот почему там все время было `[1]`: Это индекс элементов в R. Посмотрите:

```{r}
1:60
60:1
```

На этом месте также должно стать очевидно, что в отличие от кучи языков программирования R считает с 1, а не с 0.

Для того чтобы создавать арифметические прогресии существует функция `seq()`:

```{r}
1:20
seq(from = 1, to = 20, by = 1)
seq(from = 2, to = 100, by = 13)
```

```{block, type = "rmdtask"}
Используйте аргумент `length.out` функции `seq()`, чтобы создать арифметическую прогрессию от $\pi$ до $2\pi$ длины 50.

```

```{r, include=FALSE}
seq(pi, 2*pi, length.out = 50)
```

Кроме того в R есть какое-то количество встроенных векторов:

```{r}
letters
LETTERS
month.name
month.abb
```

### Приведение типов
По определению вектор может содержать только единицы **одного типа**. Но что происходит, если соединить элементы разных типов?

```{r}
c(1, "34")
c(1, TRUE)
c(TRUE, "34")
```

Мы видим иерархию: строки > числа > логические выражения. Это не универсально между разными языками программирования. Также это не зависит от количество элементов того или иного типа:

```{r}
c(1, 2, 3, "34")
c(1, TRUE, FALSE, FALSE)
```

Приведение типов может случится, во время выполнения и других операций:

```{r}
5+TRUE
```

### Операции с векторами и векторизованные операции

Все операции, которые мы раньше обсуждали, можно сделать с векторами одинаковой длины:

```{r}
1:5 + 6:10
1:5 - 6:10
1:5 * 6:10
```

Если один из векторов имеет длинну один, то получится так называемая **векторизованная операция** --- операция произойдет с каждым элементом вектора:

```{r}
1:5 + 7
1:5 - 7
1:5 / 7
```

В R очень много **векторизованных** функций:

```{r}
sin(1:5)
sqrt(1:5)
abs(-5:3)
```

### Индексирование вектора

Как получить какое-то значение или несколько значений из вектора? Нужно использовать индекс:

```{r}
x <- c(3, 0, pi, 23.4, -53)
y <- c("Нижний Новгород", "Пермь", "Санкт Петербург")

x[4]
y[2]
```

Вектор можно использовать в качестве индекса:

```{r}
x[1:2]
y[c(1, 3)]
```

Отрицательный индекс исключает элементы из вектора:
```{r}
y[-2]
x[-c(1, 4)]
```

Разумеется, в качестве индекса можно использовать переменные:

```{r}
z <- c(3, 2)
x[z]
y[z]
```

Кроме того, в качесвте индекса можно использовать вектор логических значений:

```{r}
x[c(TRUE, FALSE, TRUE, TRUE, FALSE)]
```

А это в свою очередь означает, что в качестве индекса можно использовать вектор `TRUE/FALSE`, получающийся в результате сранвения:

```{r}
x[x > 2]
```

Это работает потому что выражение `x > 2` вектор логических значений:

```{r}
x > 2
```

Как мы обсуждали раньше оператор `!` может перевернуть все логические значения на противоположные:

```{r}
x[!(x > 2)]
```

```{block, type = "rmdtask"}
Сколько элементов в векторе `g`, если выражение `g[pi < 1000]` не возвращает ошибки?
```

```{block, type = "rmdtask"}
Во встроенном датасете `Nile` содержаться данные о ежегодном разливе Нила в 1871--1970 годах (в миллиардах кубических метров). Сколько в датасете наблюдений больше 1000 и меньше 1200.
```

```{r, results='asis', echo = FALSE}
checkdown::check_question(answer = length(Nile[Nile > 1000 & Nile < 1200]))
```

### Пропущенные значения

Иногда в процессе сбора данных возникают пропущенные значения. Для представления таких данных в R используется последовательность `NA`:

```{r}
NA
c(1, NA, 9)
c("Нижний Новгород", NA, "Санкт Петербург")
c(TRUE, FALSE, NA)
```

Функция `is.na` проверяет, есть ли в векторе пропущенные значения:

```{r}
x <- c("Нижний Новгород", NA, "Санкт Петербург")
y <- c("Нижний Новгород", "Пермь", "Санкт Петербург")
is.na(x)
is.na(y)
```

Некоторые функции не работают с векторами, которые содержат пропущенные значения, и имеют аргумент для их удаления `na.rm = TRUE`:

```{r}
x <- c(1, NA, 9, 5)
mean(x)
mean(x, na.rm = TRUE)
min(x, na.rm = TRUE)
max(x, na.rm = TRUE)
median(x, na.rm = TRUE)
range(x, na.rm = TRUE)
```

```{block, type = "rmdtask"}
Сколько элементов в векторе `g`, если выражение `g[pi < 1000]` не возвращает ошибки?
```

## Пакеты

Самая большая ценность R не в нем самом, а в пакетах, которые написаны для этого языка. Более ли менее, все, что мы пока обсуждали  --- основной механизм работы R, который разработали еще в 1979. С тех пор много чего поменялось, так что все новые практики в анализе и трансформации данных хранятся в пакетах --- отдельный модуль, после загрузки которого в окружении R появляются дополнительные функции. Мы изучим наиболее популярный диалект R, который называется `tidyverse` (альтернатива -- пакет data.table).

Для установки пакета следует использовать функцию `install.packages()`

```{r, eval=FALSE}
install.packages("tidyverse")
```

Сегодня нам еще понадобиться пакет `readxl`:

```{r, eval = FALSE}
install.packages("readxl")
```

После того, как пакет установлен, его можно включить:

```{r}
library("tidyverse")
```

Не загрузка пакета --- самая частая ошибка студентов:

* `install.packages("...")` --- это как купить набор отверток;
* `library("...")` --- это как собрать и быть готовым использовать купленный набор.

![](images/01.05.install-packages-vs-library.png)

```{block, type = "rmdtask"}
Установите пакеты `tidyverse` и `readxl`. К какому пакету принадлежит функция `add_column()`?
```

```{r, results='asis', echo = FALSE}
checkdown::check_question(answer = "tibble", options = sort(c("tibble", "readr", "dplyr", "tidyr", "ggplot2", "purrr", "readxl")))
```

## Датафрейм и тиббл

Датафрейм --- это собрание векторов одинаковой длины с уникальными названиями. Вот пример датафрейма с фильмографией Тома Мура:

```{r}
moore_filmography <- tibble(title = c("The Secret of Kells", 
                                      "Song of the Sea", 
                                      "Kahlil Gibran's The Prophet", 
                                      "The Breadwinner", 
                                      "Wolfwalkers"),
                            year = c(2009, 2014, 2014, 2017, 2020),
                            director = c(TRUE, TRUE, TRUE, FALSE, TRUE))
moore_filmography
```

Существует много встроенных датафреймов:

```{r,  eval = knitr::is_html_output()}
mtcars
iris
```
  
О них точно также модно найти информацию в справке:

```{r, eval = FALSE}
?mtcars
?iris
```

Элементы датафрейма -- векторы -- можно вызывать используя знак `$`:

```{r}
moore_filmography$year
moore_filmography$title
```

К существующему датафрейму можно добавить новый вектор:

```{r}
moore_filmography$producer <- c(TRUE, TRUE, FALSE, TRUE, TRUE)
moore_filmography
```

Существует масса полезных функций, которые говорят что-то о датафрейме:

```{r}
nrow(moore_filmography)
ncol(moore_filmography)
summary(moore_filmography)
str(moore_filmography)
```

Мы будем работать исключительно с датафреймами (однако, это не единственная структура данных в R).

```{block, type = "rmdtask"}
Сколько строчек в датасете `iris`?
```

```{r, results='asis', echo = FALSE}
checkdown::check_question(answer =  nrow(iris))
```

```{block, type = "rmdtask"}
Сколько колонок в датасете `mtcars`?
```

```{r, results='asis', echo = FALSE}
checkdown::check_question(answer =  ncol(mtcars))
```

### Вызов элементов датафрейма

Датафрейм --- двумерный объект, так что можно вызывать как его строчки, так и его колонки. Это делается при помощи квадратных скобок и индексов: первый отвечает за строчки, второй -- за колонки:

```{r}
moore_filmography[3, 2]
moore_filmography[3,]
moore_filmography[,2]
moore_filmography[,1:2]
moore_filmography[,-3]
moore_filmography[,-c(1:2)]
moore_filmography[,"year"]
moore_filmography[,c("title", "year")]
moore_filmography[moore_filmography$year > 2014,]
```

## Импорт данных

### `.csv` файлы

`.csv`  файлы (comma-separated values) --- это текст, разделенный запятыми (или другими разделителями, например, табуляцией или точкой с запятой) на отдельные значения. Его широко используют, так как его одинаково легко редактировать людям и парсить компьютерам. Вот датасет `moore_filmography` в формате `.csv`:

```
title,year,director,producer
The Secret of Kells,2009,TRUE,TRUE
Song of the Sea,2014,TRUE,TRUE
Kahlil Gibran's The Prophet,2014,TRUE,FALSE
The Breadwinner,2017,FALSE,TRUE
Wolfwalkers,2020,TRUE,TRUE
```

Давайте создадим переменную с этими данными:

```{r}
our_csv <- "title,year,director,producer
The Secret of Kells,2009,TRUE,TRUE
Song of the Sea,2014,TRUE,TRUE
Kahlil Gibran's The Prophet,2014,TRUE,FALSE
The Breadwinner,2017,FALSE,TRUE
Wolfwalkers,2020,TRUE,TRUE"
```

Теперь мы можем использовать функцию `read_csv()` (из `tidyverse`):

```{r}
read_csv(our_csv)
```

Так же вы можете загрузить файл с компьютера. Скачайте [этот](https://raw.githubusercontent.com/agricolamz/2020_HSE_ds4l_NN/master/data/moore_filmography.csv) файл на компьютер (нажмите `Ctrl S` или `Cmd S`) и считайте его в:

```{r, eval=FALSE}
read_csv("C:/path/to/your/file/moore_filmography.csv")
```

```{r, echo=FALSE}
read_csv(our_csv)
```

Еще файл можно скачать непосредственно из интернета:

```{r}
read_csv("https://raw.githubusercontent.com/agricolamz/2020_HSE_ds4l_NN/master/data/moore_filmography.csv")
```

```{block, type = "rmdtask"}
Из-за пандемии про Ухань говорили во всех новостях. [По-русски](https://nplus1.ru/blog/2020/02/03/wuhan) по каким-то причинам этот город носители относят то к мужскому роду, то к женскому. Я посмотрел на другие славянские языки и записал полученные данные в [`.csv` file](https://gist.githubusercontent.com/agricolamz/c280527d6b5d79693b85d8fcf8d35bc3/raw/c46a32a218bc5d6933703ae677b81ff5a4a1dcaa/wuhan.csv). Скачайте датасет в R. Какие там переменные?
```

Все операции с файлами в R как-то связаны с памятью вашего компьютера. Чтобы узнать папку, в которой R находится, можно запустить команду `getwd()`. Рабочую дерикторию можно поменять, используя функцию `setwd()`. Если файл, с которым Вы хотите работать находится в рабочей дериктории, то нет нужды писать полный путь к файлу:

```{r, eval = FALSE}
read_csv("moore_filmography.csv")
```

Кроме того, естественно, в R существует функция, которая позволяет записывать `.csv`:

```{r, eval = FALSE}
write_csv(moore_filmography, "moore_filmography_v2.csv")
```

Иногда чтение `.csv` файлов в Microsoft Excel вызывает какие-то трудности, посмотрите [инструкции](https://www.thewindowsclub.com/how-to-convert-a-text-txt-csv-file-into-an-excel-file), если у кого-то возникнут похожие проблемы.

### файлы `.xls` и `.xlsx`

Для чтения файлов `.xsl` and `.xslx` существует пакет  `readxl`. Установите и загрузите библиотеку:

```{r}
library(readxl)
```

Вот [тестовый файл](https://github.com/agricolamz/2020.02_Naumburg_R/raw/master/data/moore_filmography.xlsx). Скачайте его к себе на компьютер, положите в рабочую дерикторию и загрузите в R:


```{r, eval= FALSE}
read_xlsx("moore_filmography.xlsx")
```
```{r, echo=FALSE}
read_xlsx("data/moore_filmography.xlsx")
```

`.xls` и `.xlsx` могут иметь разные таблиц на разных листах:


```{r, eval=FALSE}
read_xlsx("moore_filmography.xlsx", sheet = "iris")
```

```{r, echo=FALSE}
read_xlsx("data/moore_filmography.xlsx", sheet = "iris")
```
